import "EF/std_elements.met"
import "EF/mechanical_tensors.met"

# @see Variable
def type_for_nb_dim_and_sym( nb_dim, sym ) when nb_dim.size == 0
    return Op
# @see Variable
def type_for_nb_dim_and_sym( nb_dim, sym ) when nb_dim.size == 1
    return Vec[ Op, nb_dim[0] ]
# @see Variable
def type_for_nb_dim_and_sym( nb_dim, sym ) when nb_dim.size == 2
    if sym
        assert( nb_dim[0] == nb_dim[1], "symm pb" )
        return Mat[ Op, Sym[ nb_dim[0] ] ]
    return Mat[ Op, Gen[ nb_dim[0], nb_dim[1] ] ]

#~

~#
class VariableAncestor
    #
    class Symbol
        sym   := Op()
        node  := -1
        elem  := -1
        skin  := -1
        glob  := -1
        name  := ""
        ind_n := ""
        nder  := 0
        off_ind := 0
        
    # list of enrichment functions
    class EnrichList
        v := VarArgs()
        
        def init( lst ) when lst.tensor_order == 1
            v.init()
            for i in lst
                v.push_unnamed( i )
        
        def get_size
            return v.get_size()
            
        def __for__( block )
            for i in v
                block( i )
        
    # parameters
    interpolation := "nodal"
    interpolation_base := "lagrange"
    unit          := ""
    unknown       := false
    nb_der        := 0
    
    # computed
    expr_symbols  := Vec[Symbol]()
    test_symbols  := Vec[Symbol]()
    name          := ""
    tex_name      := ""
    
    # enrichment GFEM
    enrich        := EnrichList()
    nodal_enrich  := Vec[Int32]()
    nb_pattern    := 0
    
    virtual def make_expr_subs( from, to )
        abstract

    def _get_scalar_var_wo_der( e, n, ind_n, t, ind_t, sym_lst = Vec[Symbol](), interpolation_ = interpolation, interpolation_base_ = interpolation_base )
        if interpolation_ == "bubble"
            b := e.bubble_function
            return _get_scalar_var_wo_der( e, n, ind_n, t, ind_t, sym_lst, "nodal" ) * ( 1 - b ) + 
                   _get_scalar_var_wo_der( e, n, ind_n, t, ind_t, sym_lst, "nodal" ) * b
        if interpolation_ == "nodal"
            res:=Op(0)
            sym_lst_temp  :=Vec[Symbol]()
            sym_lst_temp2 :=Vec[Symbol]()
            for num_node in 0 .. e.nb_nodes
                phi_n := e.get_shape_functions( interpolation_base_ )[ num_node ]
                num_node_cpp := e.corr_cpp( num_node )
                sym_lst.push_back( sym = symbol( "$(e.name_node)($num_node_cpp)->$n$ind_n", "$(t)^{$num_node_cpp}$ind_t" ),
                    node = num_node_cpp, name = n, ind_n = ind_n, nder = nb_der )
                res += phi_n * sym_lst[sym_lst.size-1].sym
            return res
            # res := e.interpolation( sym_lst[ sym_lst.size - e.nb_nodes ... ].map( _0.sym ), interpolation_base_ )
        if interpolation_ == "vertex_nodal"
            res:=Op(0)
            sym_lst_temp  :=Vec[Symbol]()
            sym_lst_temp2 :=Vec[Symbol]()
            for num_vertex_node in 0 .. e.nb_vertex_nodes
                lambda_n := e.get_shape_functions_vertex[ num_vertex_node ]
                sym_lst.push_back( sym = symbol( "$(e.name_node)($num_vertex_node)->$n$ind_n", "$(t)^{$num_vertex_node}$ind_t" ),
                    node = num_vertex_node_cpp, name = n, ind_n = ind_n, nder = nb_der )
                res += lambda_n * sym_lst[sym_lst.size-1].sym
            return res
        if interpolation_ == "elementary"
            return sym_lst.push_back( sym = symbol( "$(e.name_elem).$n$ind_n"     , "$t$ind_t" ), elem = 0, name = n, ind_n = ind_n, nder = nb_der )->sym
        if interpolation_ == "global"
            return sym_lst.push_back( sym = symbol( "f.m->$n$ind_n"     , "$t$ind_t" ), glob = 0, name = n, ind_n = ind_n, nder = nb_der )->sym
        if interpolation_ == "skin_elementary"
            return sym_lst.push_back( sym = symbol( "skin_$(e.name_elem).$n$ind_n", "$t$ind_t" ), skin = 0, name = n, ind_n = ind_n, nder = nb_der )->sym
        assert( 0, "unknown interpolation_ '$interpolation_'" )
    
    def _get_scalar_var_wo_enr( time, e, n, t, ind, sym_lst, want_ders )
        def index_access( ind )
            res := ""
            if ind.size
                if ind.size == 1
                    res += "["
                else
                    res += "("
                for i in 0 .. ind.size
                    res += "$(ind[i])"
                    if i != ind.size - 1
                        res += ","
                if ind.size == 1
                    res += "]"
                else
                    res += ")"
            return res
        def intex_access( ind )
            if ind.size
                return "_{" + join( ind, "," ) + "}"
            return ""
        r := _get_scalar_var_wo_der( e, n, index_access( ind ), t, intex_access( ind ), sym_lst )
        for num_der in 1 .. ( nb_der + 1 ) * want_ders
            r += _get_scalar_var_wo_der( e, n + "_der_$num_der", index_access( ind ), 
                    t + "^{" + "'" * num_der + "}", intex_access( ind ) ) * time ^ num_der / factorial( num_der )
        return r
        
    def _get_scalar_var( time, e, n, t, ind, sym_lst, want_ders )
        return _get_scalar_var_wo_enr( time, e, n, t, ind, sym_lst, want_ders )
        
    def _add_scalar_var_enr( val, time, e, n, t, ind, sym_lst, want_ders, f )
        cpt_enr := 0
        for fe in enrich
            val += fe( f ) * _get_scalar_var_wo_enr( time, e, n + "_ENR_$cpt_enr", t + "^{E_{$cpt_enr}}", ind, sym_lst, want_ders )
            cpt_enr++
        
    
    virtual def get_cpp_type
        abstract
    
    virtual def default_value_str
        abstract
    
    virtual def get_nb_values
        abstract

    virtual def get_expr_tensor_order
        abstract

    virtual def get_sym_property
        abstract

    def eq( v )
        if name == v.name
            assert( interpolation == v.interpolation, "variables with same name ($name) in different formulations but with different interpolations" )
            assert( nb_values     == v.nb_values    , "variables with same name ($name) in different formulations but with different nb_values"      )
            return true
        return false
     

#~


~#
class Variable[ nb_dim = [], sym = false ] inherits VariableAncestor
    property is_a_LmtppVariable
    static const TS := type_for_nb_dim_and_sym( nb_dim, sym )
    
    #parameters
    default_value    := TS()
    
    # computed
    expr             := TS()
    test             := TS()
        
    has_relation     := false
    
    scalar_type      := "Tpos"
    
    from_formulation := Ptr[LmtppFormulationAncestor]( NULL )
    
    def reassign( value )
        has_relation = true
        expr         = value
        test         = value
        for ind, val in  indices_and_values_of( test )
            from_formulation->subs_expr_to_test( test )
        
    def mesh_symbol( ind, e )
        prefix := ""
        if interpolation == "elementary"
            prefix = "$(e.name_elem)."
        else
            assert( 0, "interpolation=$interpolation not managed" )
        #
        if nb_dim.size == 0
            return prefix + name
        if nb_dim.size == 1
            return prefix + name + "[$(ind[0])]"
        if nb_dim.size == 2
            return prefix + name + "($(ind[0]),$(ind[1]))"
        assert( 0, "nb_dim=$nb_dim not managed" )
    
    def update_computed_attributes_pass_0( time, e, n, f )
        name = n
        # TeX stuff
        if not tex_name
            tex_name = n
            if tex_name in ["sigma","nu","alpha","beta","phi","theta"]
                tex_name = "\\" + n
        for ind, val in indices_and_values_of( expr )
            val = _get_scalar_var( time, e,           name, tex_name           , ind, expr_symbols, want_ders = not unknown )
        for ind, val in indices_and_values_of( test )
            val = _get_scalar_var( time, e, "test_" + name, tex_name + "{^*}{}", ind, test_symbols, want_ders = false       )
        
    #
    def update_computed_attributes_pass_1( time, e, n, f )
        for ind, val in indices_and_values_of( expr )
            _add_scalar_var_enr( val, time, e,           name, tex_name           , ind, expr_symbols, want_ders = not unknown, f = f )
        for ind, val in indices_and_values_of( test )
            _add_scalar_var_enr( val, time, e, "test_" + name, tex_name + "{^*}{}", ind, test_symbols, want_ders = false      , f = f )
            

    virtual def get_expr_tensor_order
        return expr.tensor_order

    virtual def get_sym_property
        return sym
    
    virtual def make_expr_subs( from, to )
        expr = expr.subs( from, to )
    
    virtual def get_cpp_type
        if nb_dim.size == 0  return "Tpos"
        if nb_dim.size == 1  return "Vec<Tpos,$(nb_dim[0])>"
        if nb_dim.size == 2
            if sym
                return "Mat<Tpos,Sym<$(nb_dim[0])> >"
            return "Mat<Tpos,Gen<$(nb_dim[0]),$(nb_dim[1])> >"
        assert( 0, "TODO if nb_dim.size > 2 for C++" )
        
    virtual def get_nb_values
        if nb_dim.size == 0  return 0
        if nb_dim.size == 1  return nb_dim[0]
        if nb_dim.size == 2
            if sym return nb_dim[0] * (nb_dim[0]+1) / 2
            return nb_dim[0] * nb_dim[1]
    
    virtual def default_value_str
        res := ""; cpt := 0
        if default_value.tensor_order == 2
            res += "$(default_value.nb_rows),$(default_value.nb_cols),Vec<$scalar_type>("
        for ind, val in indices_and_values_of( default_value, compressed = true )
            res += "," * ( cpt++ != 0 ) + Float64( val ).to_string( 16 )
        if default_value.tensor_order == 2
            res += ")"
        return res

#~

~#
class LmtppFormulationAncestor
    # std variables
    time                     := symbol("time","t")
    time_beg_time_step       := symbol("f.time","ft")
    abs_time                 := time_beg_time_step + time
    time_steps               := Vec[ Op ]( size = 32, function = x => symbol("f.time_steps[$x]","\\delta t_$x") )
    
    pe                       := Ptr[ SymbolicElementAncestor ]()
    pe_children              := Vec[ Ptr[ SymbolicElementAncestor ] ]()
    
    dV                       := symbol("dV")
    dV_handbook              := symbol("dV_handbook")
    dV_enr                   := symbol("dV_enr")
    dV_corr                  := symbol("dV_corr")
    dV_coupl                 := symbol("dV_coupl")
    dV_eig_A                 := symbol("dV_eig_A")
    dV_eig_B                 := symbol("dV_eig_B")
    dV_eig_C                 := Vec[ Op ]( size = 6, function = x => symbol("dV_eig_C[$x]") )
    
    dS                       := symbol("dS")
    dS_handbook              := symbol("dS_handbook")
    dS_eig_A                 := symbol("dS_eig_A")
    dS_eig_B                 := symbol("dS_eig_B")
    dS_eig_C                 := Vec[ Op ]( size = 6, function = x => symbol("dS_eig_C[$x]") )
    diF                      := symbol("diF")
    diF_handbook             := symbol("diF_handbook")
    diF_eig_A                := symbol("diF_eig_A")
    diF_eig_B                := symbol("diF_eig_B")
    diF_eig_C                := Vec[ Op ]( size = 6, function = x => symbol("diF_eig_C[$x]") )
    dN                       := symbol("dN")
    dN_eig_A                 := symbol("dN_eig_A")
    dN_eig_B                 := symbol("dN_eig_B")
    dN_eig_C                 := Vec[ Op ]( size = 6, function = x => symbol("dN_eig_C[$x]") )
    dE                       := symbol("dE")
    dE_eig_A                 := symbol("dE_eig_A")
    dE_eig_B                 := symbol("dE_eig_B")
    dE_eig_C                 := Vec[ Op ]( size = 6, function = x => symbol("dE_eig_C[$x]") )
        
    # parameters
    left_time_integration    := 0
    right_time_integration   := 1
    use_theta_method         := 0
    theta                    := 0.5
    
    use_subs_instead_of_diff := 0
    assumed_symmetric_matrix := 1
    matrix_will_be_definite_positive := 1
    set_pos_field_as_it_was_from_lower_degree_element := 0
    
    # computed
    unknown_variables := Vec[ Ptr[ VariableAncestor ] ]()
    variables         := Vec[ Ptr[ VariableAncestor ] ]()
    unk_expr_syms     := Vec[ Ptr[ VariableAncestor::Symbol ] ]()
    unk_test_syms     := Vec[ Ptr[ VariableAncestor::Symbol ] ]()
    max_nb_der        := 0
    all_K_are_linear  := true
    
    K_dV        := Mat[ Op ]()
    K_dV_enr    := Mat[ Op ]()
    K_dV_coupl  := Mat[ Op ]()
    K_dV_corr   := Mat[ Op ]()
    
    K_dG  := Mat[ Op ]()
    K_dN  := Mat[ Op ]()
    K_dS  := Vec[ Mat[ Op ] ]()
    K_diF := Vec[ Mat[ Op ] ]()

    F_dV        := Vec[ Op ]()
    F_dV_enr    := Vec[ Op ]()
    F_dV_coupl  := Vec[ Op ]()
    F_dV_corr   := Vec[ Op ]()
    
    F_dG  := Vec[ Op ]()
    F_dN  := Vec[ Op ]()
    F_dS  := Vec[ Vec[ Op ] ]()
    F_diF := Vec[ Vec[ Op ] ]()

    A_dV  := Mat[ Op ]()
    A_dG  := Mat[ Op ]()
    A_dN  := Mat[ Op ]()
    A_dS  := Vec[ Mat[ Op ] ]()
    A_diF := Vec[ Mat[ Op ] ]()

    B_dV  := Mat[ Op ]()
    B_dG  := Mat[ Op ]()
    B_dN  := Mat[ Op ]()
    B_dS  := Vec[ Mat[ Op ] ]()
    B_diF := Vec[ Mat[ Op ] ]()

    C_dV  := Mat[ Op ]()
    C_dG  := Mat[ Op ]()
    C_dN  := Mat[ Op ]()
    C_dS  := Vec[ Mat[ Op ] ]()
    C_diF := Vec[ Mat[ Op ] ]()
    
    
    name := ""
    
    # numerical enrichment GFEM
    want_GFEM := false
    # generalized eigen problem
    want_eig := false

    virtual def formulation_init( e ) pertinence 0
        pass
    
    def subs_expr_to_test( test ) # replace expr variable to test variables in test
        for var in unknown_variables
            for es, ts in var->expr_symbols, var->test_symbols
                test = test.subs( es.sym, ts.sym )
    
    virtual def get_nb_dim
        abstract
    
    def nb_unknowns_of_type( sel )
        res := 0
        for v in unknown_variables
            for s in v->expr_symbols
                res += sel( s )
        return res
    
    static def non_null_system( K, F )
        for v in K.values +++ F
            if not assumed( v == 0 )
                return true
        return false
    
    def get_need_skin_assembly
        for n in 0 .. K_dS.size
            if non_null_system( K_dS[n], F_dS[n] )
                return true
        return false

    def get_need_internal_face_assembly
        for n in 0 .. K_diF.size
            if non_null_system( K_diF[n], F_diF[n] )
                return true
        return false
    
    #
    def call_after_solve_aux_var( e )
        cw := CodeWriter()
        for name, var in AttributeExplorer( self )
            if var.is_a_LmtppVariable and var.has_relation
                for ind, value in indices_and_values_of( var.expr, compressed = true )
                    val := value.subs( time, time_steps[0] )
                    if var.interpolation in [ "elementary", "global" ]
                        if val.depends_on( e.var_inter )
                            stderr <<< "Attention : on peut pas coller un champ non constant sur un champ qui est supposé l'être. Si par exemple vous souhaitez avoir la moyenne sur l'élément vous pouvez faire e.mean(...)."
                            # val = e.mean( val )
                            val = val.subs( e.var_inter, e.get_center_of_var_inter() )
                    cw.add( var.mesh_symbol( ind, e ), val, reassign )
        return cw.to_string()
    
    #
    virtual def call_after_solve( e ) pertinence 0.5
        return call_after_solve_aux_var( e )

    #
    def legacy_lmtpp_unk_management( t_unk, n_unk, sel )
        num_ind := 0
        cw_set := CodeWriter()
        cw_sts := CodeWriter()
        cw_get := CodeWriter()
        pts := symbol("partial_ts")
        get__initial_conditions := ""
        for v in unknown_variables
            for s in v->expr_symbols
                if sel( s )
                    interp_val := Vec[ Op ]( size = s.nder + 1, function = symbol( "vecs[$_0][indice+$num_ind]" ) )
                    interp_ste := Vec[ Op ]( size = s.nder + 1, function = time_steps[0] - sum( time_steps[ 0 .. _0 ] ) )
                    interp     := lagrange( interp_ste, interp_val, time )
                    cw_set.add( "$n_unk.$(s.name)$(s.ind_n)", interp.subs( time, time_steps[0] ), reassign )
                    cw_sts.add( "$n_unk.$(s.name)$(s.ind_n)", interp.subs( time, pts           ), reassign )
                    expr := symbol( "$n_unk.$(s.name)$(s.ind_n)" )
                    for nd in 1 .. s.nder + 1
                        interp = interp.diff( time )
                        cw_set.add( "$n_unk.$(s.name)_der_$nd$(s.ind_n)", interp.subs( time, time_steps[0] ), reassign )
                        cw_sts.add( "$n_unk.$(s.name)_der_$nd$(s.ind_n)", interp.subs( time, pts           ), reassign )
                        expr += symbol( "$n_unk.$(s.name)_der_$nd$(s.ind_n)" ) * time / factorial( nd )
                    #
                    for nd in 0 .. s.nder + 4
                        cw_get.add( "vecs[$nd][indice+$num_ind]", expr.subs( time, - sum( time_steps[ 0 .. nd ] ) ), reassign )
                    #
                    num_ind++
        #
        res := ""
        res <<<< 
                static const unsigned nb_$(t_unk)_unknowns = $( nb_unknowns_of_type( sel ) );
                template<class TE,class TTs,class Tvec>
                inline static void set_$(t_unk)_unknowns(TE &$(n_unk),const TTs &f,const Tvec &vecs,unsigned indice) {
                $( cw_set.to_string(8) )
                }
                template<class TE,class TTs,class Tvec>
                inline static void set_$(t_unk)_unknowns(TE &$(n_unk),const TTs &f,const Tvec &vecs,unsigned indice,T partial_ts) {
                $( cw_sts.to_string(8) )
                }
                template<class TE,class TTs,class Tvec>
                inline static void get_$(t_unk)_initial_conditions(const TE &$(n_unk),const TTs &f,Tvec &vecs,unsigned indice) {
                $(cw_get.to_string(8))
                }
                template<class TE,class TTs,class Tvec>
                inline static T max_$(t_unk)_error(const TE &$(n_unk),const TTs &f,const Tvec &vecs,int indice) {
                    assert( 0 );
                }
                template<class TE,class TTs,class Tvecs,class Tvec>
                inline static void set_old_vec_$(t_unk)(const TE &$(n_unk),const TTs &f,const Tvecs &vecs,Tvec &old_vec,int indice) {
                    assert( 0 );
                }
        return res
        
    #
    def write_mat( K, F, assemble_mat, assemble_vec, want_nodal, want_skin_elem, want_elem, want_global, want_assign = false, want_parallele = false )
        #
        num_inds := Vec[Int32]()
        off_inds := Vec[Int32]()
        corr_off_inds := Vec[Op]() # enrichment GFEM
        num_ind  := 0
        if want_nodal
            for s in unk_expr_syms
                if s->node >= 0
                    num_inds.push_back( s->node )
                    off_inds.push_back( s->off_ind )
                    corr_off_inds.push_back(symbol("0"))
            num_ind += pe->nb_nodes_
        
        if want_skin_elem
            has_unknown_this_kind := false
            for s in unk_expr_syms
                if s->skin >= 0
                    num_inds.push_back( num_ind )
                    off_inds.push_back( s->off_ind )
                    has_unknown_this_kind = true
                    corr_off_inds.push_back(symbol("0"))
            num_ind += has_unknown_this_kind
        
        if want_elem
            has_unknown_this_kind := false
            for s in unk_expr_syms
                if s->elem >= 0
                    num_inds.push_back( num_ind )
                    off_inds.push_back( s->off_ind )
                    has_unknown_this_kind = true
                    if want_GFEM
                        corr_off_inds.push_back(symbol("6*id"))
                    else
                        corr_off_inds.push_back(symbol("0"))
            num_ind += has_unknown_this_kind
                
        if want_global
            has_unknown_this_kind := false
            for s in unk_expr_syms
                if s->glob >= 0
                    num_inds.push_back( num_ind )
                    off_inds.push_back( s->off_ind )
                    has_unknown_this_kind = true
                    if want_GFEM
                        corr_off_inds.push_back(symbol("6*id"))
                    else
                        corr_off_inds.push_back(symbol("0"))
            num_ind += has_unknown_this_kind
            
        #
        symm := symbol("symm")
        cw := CodeWriterAlt("T") # Alt
        cw.make_cw_parallele( want_parallele )
        # t0 := time_of_day_in_sec()
        for r in 0 .. F.size
            if assemble_vec and not assumed( F[r] == 0 )
                if want_assign
                    cw.add( "F[indices[$(num_inds[r])]+$(off_inds[r])+$(corr_off_inds[r])]", F[r], reassign )
                else
                    cw.add( "F[indices[$(num_inds[r])]+$(off_inds[r])+$(corr_off_inds[r])]", F[r], add )
            if assemble_mat
                for c in 0 .. F.size
                    if not assumed( K[r,c] == 0 )
                        if want_assign
                            cw.add( "K(indices[$(num_inds[r])]+$(off_inds[r])+$(corr_off_inds[r]),indices[$(num_inds[c])]+$(off_inds[c])+$(corr_off_inds[c]))", K[r,c] * ( 1 - symm * ( c > r ) ), reassign )
                        else
                            cw.add( "K(indices[$(num_inds[r])]+$(off_inds[r])+$(corr_off_inds[r]),indices[$(num_inds[c])]+$(off_inds[c])+$(corr_off_inds[c]))", K[r,c] * ( 1 - symm * ( c > r ) ), add )
        # info time_of_day_in_sec() - t0
        return cw.to_string()
        
    #
    def write_mat_eig( A, B, assemble_mat_A, assemble_mat_B, want_nodal, want_skin_elem, want_elem, want_global, want_assign = false, want_parallele = false )
        #
        num_inds := Vec[Int32]()
        off_inds := Vec[Int32]()
        corr_off_inds := Vec[Op]() # enrichment GFEM
        num_ind  := 0
        if want_nodal
            for s in unk_expr_syms
                if s->node >= 0
                    num_inds.push_back( s->node )
                    off_inds.push_back( s->off_ind )
                    corr_off_inds.push_back(symbol("0"))
            num_ind += pe->nb_nodes_
        
        if want_skin_elem
            has_unknown_this_kind := false
            for s in unk_expr_syms
                if s->skin >= 0
                    num_inds.push_back( num_ind )
                    off_inds.push_back( s->off_ind )
                    has_unknown_this_kind = true
                    corr_off_inds.push_back(symbol("0"))
            num_ind += has_unknown_this_kind
        
        if want_elem
            has_unknown_this_kind := false
            for s in unk_expr_syms
                if s->elem >= 0
                    num_inds.push_back( num_ind )
                    off_inds.push_back( s->off_ind )
                    has_unknown_this_kind = true
                    if want_GFEM
                        corr_off_inds.push_back(symbol("6*id"))
                    else
                        corr_off_inds.push_back(symbol("0"))
            num_ind += has_unknown_this_kind
                
        if want_global
            has_unknown_this_kind := false
            for s in unk_expr_syms
                if s->glob >= 0
                    num_inds.push_back( num_ind )
                    off_inds.push_back( s->off_ind )
                    has_unknown_this_kind = true
                    if want_GFEM
                        corr_off_inds.push_back(symbol("6*id"))
                    else
                        corr_off_inds.push_back(symbol("0"))
            num_ind += has_unknown_this_kind
            
        #
        Asymm := symbol("Asymm")
        Bsymm := symbol("Bsymm")
        cw := CodeWriterAlt("T") # Alt
        cw.make_cw_parallele( want_parallele )
        # t0 := time_of_day_in_sec()
        for r in 0 .. A.nb_rows
            if assemble_mat_A
                for c in 0 .. A.nb_cols
                    if not assumed( A[r,c] == 0 )
                        if want_assign
                            cw.add( "A(indices[$(num_inds[r])]+$(off_inds[r])+$(corr_off_inds[r]),indices[$(num_inds[c])]+$(off_inds[c])+$(corr_off_inds[c]))", A[r,c] * ( 1 - Asymm * ( c > r ) ), reassign )
                        else
                            cw.add( "A(indices[$(num_inds[r])]+$(off_inds[r])+$(corr_off_inds[r]),indices[$(num_inds[c])]+$(off_inds[c])+$(corr_off_inds[c]))", A[r,c] * ( 1 - Asymm * ( c > r ) ), add )
        for r in 0 .. B.nb_rows
            if assemble_mat_B
                for c in 0 .. B.nb_cols
                    if not assumed( B[r,c] == 0 )
                        if want_assign
                            cw.add( "B(indices[$(num_inds[r])]+$(off_inds[r])+$(corr_off_inds[r]),indices[$(num_inds[c])]+$(off_inds[c])+$(corr_off_inds[c]))", B[r,c] * ( 1 - Bsymm * ( c > r ) ), reassign )
                        else
                            cw.add( "B(indices[$(num_inds[r])]+$(off_inds[r])+$(corr_off_inds[r]),indices[$(num_inds[c])]+$(off_inds[c])+$(corr_off_inds[c]))", B[r,c] * ( 1 - Bsymm * ( c > r ) ), add )
        # info time_of_day_in_sec() - t0
        return cw.to_string()

    #
    def write_mat_eq( C, assemble_mat, want_nodal, want_skin_elem, want_elem, want_global, want_assign = false, want_parallele = false )
        #
        num_inds := Vec[Int32]()
        off_inds := Vec[Int32]()
        corr_off_inds := Vec[Op]() # enrichment GFEM
        num_ind  := 0
        if want_nodal
            for s in unk_expr_syms
                if s->node >= 0
                    num_inds.push_back( s->node )
                    off_inds.push_back( s->off_ind )
                    corr_off_inds.push_back(symbol("0"))
            num_ind += pe->nb_nodes_
        
        if want_skin_elem
            has_unknown_this_kind := false
            for s in unk_expr_syms
                if s->skin >= 0
                    num_inds.push_back( num_ind )
                    off_inds.push_back( s->off_ind )
                    has_unknown_this_kind = true
                    corr_off_inds.push_back(symbol("0"))
            num_ind += has_unknown_this_kind
        
        if want_elem
            has_unknown_this_kind := false
            for s in unk_expr_syms
                if s->elem >= 0
                    num_inds.push_back( num_ind )
                    off_inds.push_back( s->off_ind )
                    has_unknown_this_kind = true
                    if want_GFEM
                        corr_off_inds.push_back(symbol("6*id"))
                    else
                        corr_off_inds.push_back(symbol("0"))
            num_ind += has_unknown_this_kind
                
        if want_global
            has_unknown_this_kind := false
            for s in unk_expr_syms
                if s->glob >= 0
                    num_inds.push_back( num_ind )
                    off_inds.push_back( s->off_ind )
                    has_unknown_this_kind = true
                    if want_GFEM
                        corr_off_inds.push_back(symbol("6*id"))
                    else
                        corr_off_inds.push_back(symbol("0"))
            num_ind += has_unknown_this_kind
            
        #
        cw := CodeWriterAlt("T") # Alt
        cw.make_cw_parallele( want_parallele )
        # t0 := time_of_day_in_sec()
        for r in 0 .. C.nb_rows
            if assemble_mat
                for c in 0 .. C.nb_cols
                    if not assumed( C[r,c] == 0 )
                        if want_assign
                            cw.add( "C($r,indices[$(num_inds[c])]+$(off_inds[c])+$(corr_off_inds[c]))", C[r,c], reassign )
                        else
                            cw.add( "C($r,indices[$(num_inds[c])]+$(off_inds[c])+$(corr_off_inds[c]))", C[r,c], add )
        # info time_of_day_in_sec() - t0
        return cw.to_string()
        
    # 
    def write_mat_with_cond( K, F, assemble_mat, assemble_vec, want_nodal, want_skin_elem, want_elem, want_global, want_assign = false, want_parallele = false, line_range_min = 0, line_range_max = F.size )
        #
        num_inds := Vec[Int32]()
        off_inds := Vec[Int32]()
        corr_off_inds := Vec[Op]() # enrichment GFEM
        num_ind  := 0
        if want_nodal
            for s in unk_expr_syms
                if s->node >= 0
                    num_inds.push_back( s->node )
                    off_inds.push_back( s->off_ind )
                    corr_off_inds.push_back(symbol("0"))
            num_ind += pe->nb_nodes_

        if want_skin_elem
            has_unknown_this_kind := false
            for s in unk_expr_syms
                if s->skin >= 0
                    num_inds.push_back( num_ind )
                    off_inds.push_back( s->off_ind )
                    has_unknown_this_kind = true
                    corr_off_inds.push_back(symbol("0"))
            num_ind += has_unknown_this_kind

        if want_elem
            has_unknown_this_kind := false
            for s in unk_expr_syms
                if s->elem >= 0
                    num_inds.push_back( num_ind )
                    off_inds.push_back( s->off_ind )
                    has_unknown_this_kind = true
                    if want_GFEM
                        corr_off_inds.push_back(symbol("id_offset"))
                    else
                        corr_off_inds.push_back(symbol("0"))
            num_ind += has_unknown_this_kind

        if want_global
            has_unknown_this_kind := false
            for s in unk_expr_syms
                if s->glob >= 0
                    num_inds.push_back( num_ind )
                    off_inds.push_back( s->off_ind )
                    has_unknown_this_kind = true
                    if want_GFEM
                        corr_off_inds.push_back(symbol("id_offset")) 
                    else
                        corr_off_inds.push_back(symbol("0"))
            num_ind += has_unknown_this_kind

        #
        symm := symbol("symm")
        cw := CodeWriterAlt("T") # Alt
        cw.make_cw_parallele( want_parallele )
        # t0 := time_of_day_in_sec()
        for r in 0 .. F.size
            if assemble_vec and not assumed( F[r] == 0 ) and r > line_range_min and r < line_range_max
                if want_assign
                    cw.add( "F[indices[$(num_inds[r])]+$(off_inds[r])+$(corr_off_inds[r])]", F[r], reassign )
                else
                    cw.add( "F[indices[$(num_inds[r])]+$(off_inds[r])+$(corr_off_inds[r])]", F[r], add )
            if assemble_mat
                for c in 0 .. F.size 
                    if not assumed( K[r,c] == 0 ) and ( (c > line_range_min and c < line_range_max) or (r > line_range_min and r < line_range_max) ) and c < line_range_max and r < line_range_max
                        if want_assign
                            cw.add( "K(indices[$(num_inds[r])]+$(off_inds[r])+$(corr_off_inds[r]),indices[$(num_inds[c])]+$(off_inds[c])+$(corr_off_inds[c]))", K[r,c] * ( 1 - symm * ( c > r ) ), reassign )
                        else
                            cw.add( "K(indices[$(num_inds[r])]+$(off_inds[r])+$(corr_off_inds[r]),indices[$(num_inds[c])]+$(off_inds[c])+$(corr_off_inds[c]))", K[r,c] * ( 1 - symm * ( c > r ) ), add )
        # info time_of_day_in_sec() - t0
        return cw.to_string()
        
    #
    def write_mat_zero( K, F, assemble_mat, assemble_vec, want_nodal, want_skin_elem, want_elem, want_global, want_parallele = false )
        #
        num_inds := Vec[Int32]()
        off_inds := Vec[Int32]()
        corr_off_inds := Vec[Op]() # enrichment GFEM
        num_ind  := 0
        if want_nodal
            for s in unk_expr_syms
                if s->node >= 0
                    num_inds.push_back( s->node )
                    off_inds.push_back( s->off_ind )
                    corr_off_inds.push_back(symbol("0"))
            num_ind += pe->nb_nodes_

        if want_skin_elem
            has_unknown_this_kind := false
            for s in unk_expr_syms
                if s->skin >= 0
                    num_inds.push_back( num_ind )
                    off_inds.push_back( s->off_ind )
                    has_unknown_this_kind = true
                    corr_off_inds.push_back(symbol("0"))
            num_ind += has_unknown_this_kind

        if want_elem
            has_unknown_this_kind := false
            for s in unk_expr_syms
                if s->elem >= 0
                    num_inds.push_back( num_ind )
                    off_inds.push_back( s->off_ind )
                    has_unknown_this_kind = true
                    if want_GFEM
                        corr_off_inds.push_back(symbol("6*id"))
                    else
                        corr_off_inds.push_back(symbol("0"))
            num_ind += has_unknown_this_kind

        if want_global
            has_unknown_this_kind := false
            for s in unk_expr_syms
                if s->glob >= 0
                    num_inds.push_back( num_ind )
                    off_inds.push_back( s->off_ind )
                    has_unknown_this_kind = true
                    if want_GFEM
                        corr_off_inds.push_back(symbol("6*id"))
                    else
                        corr_off_inds.push_back(symbol("0"))
            num_ind += has_unknown_this_kind

        #
        symm := symbol("symm")
        cw := CodeWriterAlt("T") # Alt
        cw.make_cw_parallele( want_parallele )
        # t0 := time_of_day_in_sec()
        for r in 0 .. F.size
            if assemble_vec and not assumed( F[r] == 0 )
                cw.add( "F[indices[$(num_inds[F.size-1])]+$(off_inds[r])+$(corr_off_inds[r])]", Op(0), reassign )
            if assemble_mat
                for c in 0 .. F.size
                    if not assumed( K[r,c] == 0 )
                        cw.add( "K(indices[$(num_inds[F.size-1])]+$(off_inds[r])+$(corr_off_inds[r]),indices[$(num_inds[F.size-1])]+$(off_inds[c])+$(corr_off_inds[c]))", Op(0) * ( 1 - symm * ( c > r ) ), reassign )
        # info time_of_day_in_sec() - t0
        return cw.to_string()
        
    #
    def write_add_elem_matrices( stream )
        appel_K := "TK K_tmp; K_tmp.resize( f.matrices(Number<0>()).nb_rows() ); K_tmp.clear();"
        appel_F := "TF F_tmp; F_tmp.resize( f.sollicitation.size() ); F_tmp.set(0.);"
        appel_enr := "add_elem_matrix_enriched( f, K_tmp, F_tmp, f.vectors, matrix_is_sym, assemble_mat, assemble_vec, elem, indices );"
        appel_corr:= "add_elem_matrix_enriched_corr( f, f.matrices(Number<0>()), f.sollicitation, f.vectors, matrix_is_sym, assemble_mat, assemble_vec, elem, indices );"
        sum_K := "pthread_mutex_lock(mutex); f.matrices(Number<0>()) += K_tmp; f.sollicitation += F_tmp; pthread_mutex_unlock(mutex);"
        stream <<< "#ifndef ADD_ELEM_MATRIX_$(nb_dim)_$(name)_FOR_ELEMENT_$(pe->name)_H"
        stream <<< "#define ADD_ELEM_MATRIX_$(nb_dim)_$(name)_FOR_ELEMENT_$(pe->name)_H"
        stream <<< "namespace LMT {"
        for assemble_mat in 0 .. 2
            for assemble_vec in 0 .. 2
                stream <<<<
                    // 
                    template<class TM,class T,bool wont_add_nz,class TK,class TF,class TV,unsigned symm,class T_pos,class ND,class ED,unsigned nim>
                    void add_elem_matrix(
                        Formulation<TM,$name,DefaultBehavior,T,wont_add_nz> &f,
                        TK &K,
                        TF &F,
                        TV &vectors,
                        const Number<symm> &matrix_is_sym,
                        const Number<$assemble_mat> &assemble_mat,
                        const Number<$assemble_vec> &assemble_vec,
                        const Element<$(pe->name),DefaultBehavior,Node<$nb_dim,T_pos,ND>,ED,nim> &elem,
                        const unsigned *indices ) {
                        pthread_mutex_t* mutex = &f.mutex;
                        #define PNODE(N) elem.node(N)
                    $( write_mat( K_dV, F_dV, assemble_mat, assemble_vec, want_nodal=true, want_skin_elem=true, want_elem=true, want_global=true, want_parallele=want_GFEM ) )
                if want_GFEM
                    stream <<<<
                        $(appel_K)
                        $(appel_F)
                        $(appel_enr)
                        $(sum_K)
                stream <<<<
                        #undef PNODE
                    }
                    //
                    template<class TM,class T,bool wont_add_nz,unsigned symm,class T_pos,class ND,class ED,unsigned nim>
                    void add_elem_matrix(
                        Formulation<TM,$name,DefaultBehavior,T,wont_add_nz> &f,
                        const Number<symm> &matrix_is_sym,
                        const Number<$assemble_mat> &assemble_mat,
                        const Number<$assemble_vec> &assemble_vec,
                        const Element<$(pe->name),DefaultBehavior,Node<$nb_dim,T_pos,ND>,ED,nim> &elem,
                        const unsigned *indices ) {
                        add_elem_matrix( f, f.matrices(Number<0>()), f.sollicitation, f.vectors, matrix_is_sym, assemble_mat, assemble_vec, elem, indices );
                    }
                
                for pc, num_pc in pe_children, 0...
                    stream <<<<
                        // 
                        template<class TM,class T,bool wont_add_nz,class TK,class TF,class TV,unsigned symm,class T_pos,class ND,class ED,unsigned nim,class ED2,unsigned nim2>
                        void add_skin_elem_matrix(
                            Formulation<TM,$name,DefaultBehavior,T,wont_add_nz> &f,
                            TK &K,
                            TF &F,
                            TV &vectors,
                            const Number<symm> &matrix_is_sym,
                            const Number<$assemble_mat> &assemble_mat,
                            const Number<$assemble_vec> &assemble_vec,
                            const Element<$(pe->name),DefaultBehavior,Node<$nb_dim,T_pos,ND>,ED,nim> &elem,
                            const Element<$(pc->name),DefaultBehavior,Node<$nb_dim,T_pos,ND>,ED2,nim2> &skin_elem,
                            const Number<$num_pc> &num_child,
                            const unsigned *indices ) {
                            pthread_mutex_t* mutex = &f.mutex;
                            #define PNODE(N) elem.node(N)
                        $( write_mat( K_dS[num_pc], F_dS[num_pc], assemble_mat, assemble_vec, want_nodal=true, want_skin_elem=true, want_elem=true, want_global=true, want_parallele=want_GFEM ) )
                            #undef PNODE
                        }
                    stream <<<<
                        // 
                        template<class TM,class T,bool wont_add_nz,unsigned symm,class T_pos,class ND,class ED,unsigned nim,class ED2,unsigned nim2>
                        void add_skin_elem_matrix(
                            Formulation<TM,$name,DefaultBehavior,T,wont_add_nz> &f,
                            const Number<symm> &matrix_is_sym,
                            const Number<$assemble_mat> &assemble_mat,
                            const Number<$assemble_vec> &assemble_vec,
                            const Element<$(pe->name),DefaultBehavior,Node<$nb_dim,T_pos,ND>,ED,nim> &elem,
                            const Element<$(pc->name),DefaultBehavior,Node<$nb_dim,T_pos,ND>,ED2,nim2> &skin_elem,
                            const Number<$num_pc> &num_child,
                            const unsigned *indices ) {
                            add_skin_elem_matrix( f, f.matrices(Number<0>()), f.sollicitation, f.vectors, matrix_is_sym, assemble_mat, assemble_vec, elem, skin_elem, num_child, indices );
                        }
                    stream <<<<
                        // 
                        template<class TM,class T,bool wont_add_nz,class TK,class TF,class TV,unsigned symm,class T_pos,class ND,class ED,unsigned nim,class ED2,unsigned nim2>
                        void add_internal_face_matrix(
                            Formulation<TM,$name,DefaultBehavior,T,wont_add_nz> &f,
                            TK &K,
                            TF &F,
                            TV &vectors,
                            const Number<symm> &matrix_is_sym,
                            const Number<$assemble_mat> &assemble_mat,
                            const Number<$assemble_vec> &assemble_vec,
                            const Element<$(pe->name),DefaultBehavior,Node<$nb_dim,T_pos,ND>,ED,nim> &elem,
                            const Element<$(pc->name),DefaultBehavior,Node<$nb_dim,T_pos,ND>,ED2,nim2> &skin_elem,
                            const Number<$num_pc> &num_child,
                            const unsigned *indices ) {
                            pthread_mutex_t* mutex = &f.mutex;
                            #define PNODE(N) elem.node(N)
                        $( write_mat( K_diF[num_pc], F_diF[num_pc], assemble_mat, assemble_vec, want_nodal=true, want_skin_elem=true, want_elem=true, want_global=true, want_parallele=want_GFEM ) )
                            #undef PNODE
                        }
                    stream <<<<
                        // 
                        template<class TM,class T,bool wont_add_nz,unsigned symm,class T_pos,class ND,class ED,unsigned nim,class ED2,unsigned nim2>
                        void add_internal_face_matrix(
                            Formulation<TM,$name,DefaultBehavior,T,wont_add_nz> &f,
                            const Number<symm> &matrix_is_sym,
                            const Number<$assemble_mat> &assemble_mat,
                            const Number<$assemble_vec> &assemble_vec,
                            const Element<$(pe->name),DefaultBehavior,Node<$nb_dim,T_pos,ND>,ED,nim> &elem,
                            const Element<$(pc->name),DefaultBehavior,Node<$nb_dim,T_pos,ND>,ED2,nim2> &skin_elem,
                            const Number<$num_pc> &num_child,
                            const unsigned *indices ) {
                            add_internal_face_matrix( f, f.matrices(Number<0>()), f.sollicitation, f.vectors, matrix_is_sym, assemble_mat, assemble_vec, elem, skin_elem, num_child, indices );
                        }
        stream <<< "} // namespace LMT"
        stream <<< "#endif"
        
    #
    def write_add_elem_matrices_eig( stream )
        stream <<< "#ifndef ADD_ELEM_MATRIX_EIG_$(nb_dim)_$(name)_FOR_ELEMENT_$(pe->name)_H"
        stream <<< "#define ADD_ELEM_MATRIX_EIG_$(nb_dim)_$(name)_FOR_ELEMENT_$(pe->name)_H"
        for assemble_mat_A in 0 .. 2
            for assemble_mat_B in 0 .. 2
                stream <<<<
                    // 
                    template<class TM,class T,bool wont_add_nz,class TK,class TV,unsigned Asymm,unsigned Bsymm,class T_pos,class ND,class ED,unsigned nim>
                    void add_elem_matrix(
                        Formulation<TM,$name,DefaultBehavior,T,wont_add_nz> &f,
                        TK &A,
                        TK &B,
                        TV &vectors,
                        const Number<Asymm> &matrix_A_is_sym,
                        const Number<Bsymm> &matrix_B_is_sym,
                        const Number<$assemble_mat_A> &assemble_mat_A,
                        const Number<$assemble_mat_B> &assemble_mat_B,
                        const Element<$(pe->name),DefaultBehavior,Node<$nb_dim,T_pos,ND>,ED,nim> &elem,
                        const unsigned *indices ) {
                        pthread_mutex_t* mutex = &f.mutex;
                        #define PNODE(N) elem.node(N)
                    $( write_mat_eig( A_dV, B_dV, assemble_mat_A, assemble_mat_B, want_nodal=true, want_skin_elem=true, want_elem=true, want_global=true, want_parallele=want_GFEM ) )
                        #undef PNODE
                    }
                    //
                    template<class TM,class T,bool wont_add_nz,unsigned Asymm,unsigned Bsymm,class T_pos,class ND,class ED,unsigned nim>
                    void add_elem_matrix(
                        Formulation<TM,$name,DefaultBehavior,T,wont_add_nz> &f,
                        const Number<Asymm> &matrix_A_is_sym,
                        const Number<Bsymm> &matrix_B_is_sym,
                        const Number<$assemble_mat_A> &assemble_mat_A,
                        const Number<$assemble_mat_B> &assemble_mat_B,
                        const Element<$(pe->name),DefaultBehavior,Node<$nb_dim,T_pos,ND>,ED,nim> &elem,
                        const unsigned *indices ) {
                        add_elem_matrix( f, f.matrices(Number<1>()), f.matrices(Number<2>()), f.vectors, matrix_A_is_sym, matrix_B_is_sym, assemble_mat_A, assemble_mat_B, elem, indices );
                    }
                
                for pc, num_pc in pe_children, 0...
                    stream <<<<
                        // 
                        template<class TM,class T,bool wont_add_nz,class TK,class TV,unsigned Asymm,unsigned Bsymm,class T_pos,class ND,class ED,unsigned nim,class ED2,unsigned nim2>
                        void add_skin_elem_matrix(
                            Formulation<TM,$name,DefaultBehavior,T,wont_add_nz> &f,
                            TK &A,
                            TK &B,
                            TV &vectors,
                            const Number<Asymm> &matrix_A_is_sym,
                            const Number<Bsymm> &matrix_B_is_sym,
                            const Number<$assemble_mat_A> &assemble_mat_A,
                            const Number<$assemble_mat_B> &assemble_mat_B,
                            const Element<$(pe->name),DefaultBehavior,Node<$nb_dim,T_pos,ND>,ED,nim> &elem,
                            const Element<$(pc->name),DefaultBehavior,Node<$nb_dim,T_pos,ND>,ED2,nim2> &skin_elem,
                            const Number<$num_pc> &num_child,
                            const unsigned *indices ) {
                            pthread_mutex_t* mutex = &f.mutex;
                            #define PNODE(N) elem.node(N)
                        $( write_mat_eig( A_dS[num_pc], B_dS[num_pc], assemble_mat_A, assemble_mat_B, want_nodal=true, want_skin_elem=true, want_elem=true, want_global=true, want_parallele=want_GFEM ) )
                            #undef PNODE
                        }
                    stream <<<<
                        // 
                        template<class TM,class T,bool wont_add_nz,unsigned Asymm,unsigned Bsymm,class T_pos,class ND,class ED,unsigned nim,class ED2,unsigned nim2>
                        void add_skin_elem_matrix(
                            Formulation<TM,$name,DefaultBehavior,T,wont_add_nz> &f,
                            const Number<Asymm> &matrix_A_is_sym,
                            const Number<Bsymm> &matrix_B_is_sym,
                            const Number<$assemble_mat_A> &assemble_mat_A,
                            const Number<$assemble_mat_B> &assemble_mat_B,
                            const Element<$(pe->name),DefaultBehavior,Node<$nb_dim,T_pos,ND>,ED,nim> &elem,
                            const Element<$(pc->name),DefaultBehavior,Node<$nb_dim,T_pos,ND>,ED2,nim2> &skin_elem,
                            const Number<$num_pc> &num_child,
                            const unsigned *indices ) {
                            add_skin_elem_matrix( f, f.matrices(Number<1>()), f.matrices(Number<2>()), f.vectors, matrix_A_is_sym, matrix_B_is_sym, assemble_mat_A, assemble_mat_B, elem, skin_elem, num_child, indices );
                        }
                    stream <<<<
                        // 
                        template<class TM,class T,bool wont_add_nz,class TK,class TV,unsigned Asymm,unsigned Bsymm,class T_pos,class ND,class ED,unsigned nim,class ED2,unsigned nim2>
                        void add_internal_face_matrix(
                            Formulation<TM,$name,DefaultBehavior,T,wont_add_nz> &f,
                            TK &A,
                            TK &B,
                            TV &vectors,
                            const Number<Asymm> &matrix_A_is_sym,
                            const Number<Bsymm> &matrix_B_is_sym,
                            const Number<$assemble_mat_A> &assemble_mat_A,
                            const Number<$assemble_mat_B> &assemble_mat_B,
                            const Element<$(pe->name),DefaultBehavior,Node<$nb_dim,T_pos,ND>,ED,nim> &elem,
                            const Element<$(pc->name),DefaultBehavior,Node<$nb_dim,T_pos,ND>,ED2,nim2> &skin_elem,
                            const Number<$num_pc> &num_child,
                            const unsigned *indices ) {
                            pthread_mutex_t* mutex = &f.mutex;
                            #define PNODE(N) elem.node(N)
                        $( write_mat_eig( A_diF[num_pc], B_diF[num_pc], assemble_mat_A, assemble_mat_B, want_nodal=true, want_skin_elem=true, want_elem=true, want_global=true, want_parallele=want_GFEM ) )
                            #undef PNODE
                        }
                    stream <<<<
                        // 
                        template<class TM,class T,bool wont_add_nz,unsigned Asymm,unsigned Bsymm,class T_pos,class ND,class ED,unsigned nim,class ED2,unsigned nim2>
                        void add_internal_face_matrix(
                            Formulation<TM,$name,DefaultBehavior,T,wont_add_nz> &f,
                            const Number<Asymm> &matrix_A_is_sym,
                            const Number<Bsymm> &matrix_B_is_sym,
                            const Number<$assemble_mat_A> &assemble_mat_A,
                            const Number<$assemble_mat_B> &assemble_mat_B,
                            const Element<$(pe->name),DefaultBehavior,Node<$nb_dim,T_pos,ND>,ED,nim> &elem,
                            const Element<$(pc->name),DefaultBehavior,Node<$nb_dim,T_pos,ND>,ED2,nim2> &skin_elem,
                            const Number<$num_pc> &num_child,
                            const unsigned *indices ) {
                            add_internal_face_matrix( f, f.matrices(Number<1>()), f.matrices(Number<2>()), f.vectors, matrix_A_is_sym, matrix_B_is_sym, assemble_mat_A, assemble_mat_B, elem, skin_elem, num_child, indices );
                        }
        for assemble_mat in 0 .. 2
            stream <<<<
                // 
                template<class TM,class T,bool wont_add_nz,class TK,class TV,unsigned symm,class T_pos,class ND,class ED,unsigned nim>
                void add_elem_matrix(
                    Formulation<TM,$name,DefaultBehavior,T,wont_add_nz> &f,
                    TK &C,
                    TV &vectors,
                    const Number<symm> &matrix_is_sym,
                    const Number<$assemble_mat> &assemble_mat,
                    const Element<$(pe->name),DefaultBehavior,Node<$nb_dim,T_pos,ND>,ED,nim> &elem,
                    const unsigned *indices ) {
                    pthread_mutex_t* mutex = &f.mutex;
                    #define PNODE(N) elem.node(N)
                $( write_mat_eq( C_dV, assemble_mat, want_nodal=true, want_skin_elem=true, want_elem=true, want_global=true, want_parallele=want_GFEM ) )
                    #undef PNODE
                }
                //
                template<class TM,class T,bool wont_add_nz,unsigned symm,class T_pos,class ND,class ED,unsigned nim>
                void add_elem_matrix(
                    Formulation<TM,$name,DefaultBehavior,T,wont_add_nz> &f,
                    const Number<symm> &matrix_is_sym,
                    const Number<$assemble_mat> &assemble_mat,
                    const Element<$(pe->name),DefaultBehavior,Node<$nb_dim,T_pos,ND>,ED,nim> &elem,
                    const unsigned *indices ) {
                    add_elem_matrix( f, f.matrices(Number<3>()), f.vectors, matrix_is_sym, assemble_mat, elem, indices );
                }
            
            for pc, num_pc in pe_children, 0...
                stream <<<<
                    // 
                    template<class TM,class T,bool wont_add_nz,class TK,class TV,unsigned symm,class T_pos,class ND,class ED,unsigned nim,class ED2,unsigned nim2>
                    void add_skin_elem_matrix(
                        Formulation<TM,$name,DefaultBehavior,T,wont_add_nz> &f,
                        TK &C,
                        TV &vectors,
                        const Number<symm> &matrix_is_sym,
                        const Number<$assemble_mat> &assemble_mat,
                        const Element<$(pe->name),DefaultBehavior,Node<$nb_dim,T_pos,ND>,ED,nim> &elem,
                        const Element<$(pc->name),DefaultBehavior,Node<$nb_dim,T_pos,ND>,ED2,nim2> &skin_elem,
                        const Number<$num_pc> &num_child,
                        const unsigned *indices ) {
                        pthread_mutex_t* mutex = &f.mutex;
                        #define PNODE(N) elem.node(N)
                    $( write_mat_eq( C_dS[num_pc], assemble_mat, want_nodal=true, want_skin_elem=true, want_elem=true, want_global=true, want_parallele=want_GFEM ) )
                        #undef PNODE
                    }
                stream <<<<
                    // 
                    template<class TM,class T,bool wont_add_nz,unsigned symm,class T_pos,class ND,class ED,unsigned nim,class ED2,unsigned nim2>
                    void add_skin_elem_matrix(
                        Formulation<TM,$name,DefaultBehavior,T,wont_add_nz> &f,
                        const Number<symm> &matrix_is_sym,
                        const Number<$assemble_mat> &assemble_mat,
                        const Element<$(pe->name),DefaultBehavior,Node<$nb_dim,T_pos,ND>,ED,nim> &elem,
                        const Element<$(pc->name),DefaultBehavior,Node<$nb_dim,T_pos,ND>,ED2,nim2> &skin_elem,
                        const Number<$num_pc> &num_child,
                        const unsigned *indices ) {
                        add_skin_elem_matrix( f, f.matrices(Number<3>()), f.vectors, matrix_is_sym, assemble_mat, elem, skin_elem, num_child, indices );
                    }
                stream <<<<
                    // 
                    template<class TM,class T,bool wont_add_nz,class TK,class TV,unsigned symm,class T_pos,class ND,class ED,unsigned nim,class ED2,unsigned nim2>
                    void add_internal_face_matrix(
                        Formulation<TM,$name,DefaultBehavior,T,wont_add_nz> &f,
                        TK &C,
                        TV &vectors,
                        const Number<symm> &matrix_is_sym,
                        const Number<$assemble_mat> &assemble_mat,
                        const Element<$(pe->name),DefaultBehavior,Node<$nb_dim,T_pos,ND>,ED,nim> &elem,
                        const Element<$(pc->name),DefaultBehavior,Node<$nb_dim,T_pos,ND>,ED2,nim2> &skin_elem,
                        const Number<$num_pc> &num_child,
                        const unsigned *indices ) {
                        pthread_mutex_t* mutex = &f.mutex;
                        #define PNODE(N) elem.node(N)
                    $( write_mat_eq( C_diF[num_pc], assemble_mat, want_nodal=true, want_skin_elem=true, want_elem=true, want_global=true, want_parallele=want_GFEM ) )
                        #undef PNODE
                    }
                stream <<<<
                    // 
                    template<class TM,class T,bool wont_add_nz,unsigned symm,class T_pos,class ND,class ED,unsigned nim,class ED2,unsigned nim2>
                    void add_internal_face_matrix(
                        Formulation<TM,$name,DefaultBehavior,T,wont_add_nz> &f,
                        const Number<symm> &matrix_is_sym,
                        const Number<$assemble_mat> &assemble_mat,
                        const Element<$(pe->name),DefaultBehavior,Node<$nb_dim,T_pos,ND>,ED,nim> &elem,
                        const Element<$(pc->name),DefaultBehavior,Node<$nb_dim,T_pos,ND>,ED2,nim2> &skin_elem,
                        const Number<$num_pc> &num_child,
                        const unsigned *indices ) {
                        add_internal_face_matrix( f, f.matrices(Number<3>()), f.vectors, matrix_is_sym, assemble_mat, elem, skin_elem, num_child, indices );
                    }
        stream <<< "} // namespace LMT"
        stream <<< "#endif"

    #
    def write_add_elem_matrices_enriched( stream )
        stream <<< "#ifndef ADD_ELEM_MATRIX_ENRICHED_$(nb_dim)_$(name)_FOR_ELEMENT_$(pe->name)_H"
        stream <<< "#define ADD_ELEM_MATRIX_ENRICHED_$(nb_dim)_$(name)_FOR_ELEMENT_$(pe->name)_H"
        stream <<< "namespace LMT {"
        e := child_cast(pe)
        toto := e->point_is_inside([symbol("f.interface.handbooks[f.interface.elem_enrichment_ID[elem.number][j]].pts_gauss_hdbk.pos_and_wei[i].positions[0]") symbol("f.interface.handbooks[f.interface.elem_enrichment_ID[elem.number][j]].pts_gauss_hdbk.pos_and_wei[i].positions[1]")])
        #
        if nb_dim == 2
          stream <<<<
              template<class TM,class T,bool wont_add_nz,unsigned symm,class T_pos,class ND,class ED,unsigned nim, unsigned ass_mat, unsigned ass_vec, class TO, class THDBK>
              struct add_elem_matrix_struct_$(pe->name) { 
                  const Number<symm> *matrix_is_sym;
                  const Number<ass_mat> *assemble_mat;
                  const Number<ass_vec> *assemble_vec;
                  const Element<$(pe->name),DefaultBehavior,Node<$nb_dim,T_pos,ND>,ED,nim> *elem;
                  Formulation<TM,$name,DefaultBehavior,T,wont_add_nz> *f ;
                  const unsigned *indices;
                  const unsigned *id;
                  const unsigned *id_group_hdbk;
                  const unsigned *id_hdbk;
                  THDBK* hdbk;
                  template<class TE1,class TE2,class TE3, class TK, class TF> void operator()( const TE1 elem_enr, const TE2 elem_enr1, const TE3 elem_enr2, TK &K, TF &F) const {
                      //indices[$(pe->nb_nodes_)] = hdbk->indices;
                      Gauss_Pts_for_one_element<TM,TE1> gauss_point;
                      gauss_point.prout( elem_enr, hdbk);
                      for (unsigned i=0;i<gauss_point.size();i++) {
                          if(/* pos_is_inside(*elem,gauss_point[i].positions,10e-4)*/ 1) {
                              add_elem_matrix_enriched_corr( *f, K, F, f->vectors, *matrix_is_sym, *assemble_mat, *assemble_vec, *elem, indices, gauss_point[i], *id_group_hdbk, elem_enr, elem_enr1, elem_enr2, hdbk);
                              add_elem_matrix_enriched_coupl( *f, K, F, f->vectors, *matrix_is_sym, *assemble_mat, *assemble_vec, *elem, indices, gauss_point[i], *id_group_hdbk, elem_enr, elem_enr1,elem_enr2, hdbk);
                              add_elem_matrix_enriched( *f, K, F, f->vectors, *matrix_is_sym, *assemble_mat, *assemble_vec, *elem, indices, gauss_point[i], *id_group_hdbk, elem_enr, elem_enr1,elem_enr2, hdbk);
                          }
                      }
                  }
              };
          for assemble_mat in 0 .. 2
              for assemble_vec in 0 .. 2
                  stream <<<<
                      // 
                      //
                      template<class TM,class T,bool wont_add_nz,class TK,class TF,class TV, class TVV,unsigned symm,class T_pos,class ND,class ED,unsigned nim, class TEE, class TEE2, class TEE3, class THDBK>
                      void add_elem_matrix_enriched(
                          Formulation<TM,$name,DefaultBehavior,T,wont_add_nz> &f,
                          TK &K,
                          TF &F,
                          TV &vectors,
                          const Number<symm> &matrix_is_sym,
                          const Number<$assemble_mat> &assemble_mat,
                          const Number<$assemble_vec> &assemble_vec,
                          const Element<$(pe->name),DefaultBehavior,Node<$nb_dim,T_pos,ND>,ED,nim> &elem,
                          const unsigned *indices, const TVV &gauss_point, const unsigned &id_group_hdbk,const TEE &elem_enr,const TEE2 &elem_enr2,const TEE3 &elem_enr3, THDBK* hdbk ) {
                              unsigned id = id_group_hdbk;
                              Interface_micro_macro_handbook_values_<TM,THDBK,TEE,TEE2,TEE3> Fun_enr(&f.interface,hdbk,elem_enr,elem_enr2,elem_enr3);
                              Interface_micro_macro_handbook_values_dx_<TM,THDBK,TEE,TEE2,TEE3> Fun_enr_dx(&f.interface,hdbk,elem_enr,elem_enr2,elem_enr3);
                              Interface_micro_macro_handbook_values_dy_<TM,THDBK,TEE,TEE2,TEE3> Fun_enr_dy(&f.interface,hdbk,elem_enr,elem_enr2,elem_enr3);
                              Interface_micro_macro_handbook_values_young_<TM,THDBK,TEE> Young_enr(&f.interface,hdbk,elem_enr);
                              Interface_micro_macro_handbook_values_poisson_<TM,THDBK,TEE> Poisson_enr(&f.interface,hdbk,elem_enr);
                              // std::cout<<indices[0]<< " " << indices[1]<< " " << indices[2] << " " << indices[3]<< " " << indices[4]<<std::endl;
                      pthread_mutex_t* mutex = &f.mutex;
                      $( write_mat( K_dV_enr, F_dV_enr, assemble_mat, assemble_vec, want_nodal=true, want_skin_elem=true, want_elem=true, want_global=true, want_assign=false, want_parallele=false ) )
                      }
                      //
                      template<class TM,class T,bool wont_add_nz,class TK,class TF,class TV, unsigned symm,class T_pos,class ND,class ED,unsigned nim>
                      void put_elem_matrix_enriched_zero(
                          Formulation<TM,$name,DefaultBehavior,T,wont_add_nz> &f,
                          TK &K,
                          TF &F,
                          const TV &vectors,
                          const Number<symm> &matrix_is_sym,
                          const Number<$assemble_mat> &assemble_mat,
                          const Number<$assemble_vec> &assemble_vec,
                          const Element<$(pe->name),DefaultBehavior,Node<$nb_dim,T_pos,ND>,ED,nim> &elem,
                          const unsigned *indices, const unsigned &id_group_hdbk ) {
                              unsigned id = id_group_hdbk;
                      $( write_mat_zero( K_dV_enr, F_dV_enr, assemble_mat, assemble_vec, want_nodal=true, want_skin_elem=true, want_elem=true, want_global=true, want_parallele=false ) )
                      }
                      //
                      //
                      template<class TM,class T,bool wont_add_nz,class TK,class TF,class TV,unsigned symm,class T_pos,class ND,class ED,unsigned nim>
                      void add_elem_matrix_enriched(
                          Formulation<TM,$name,DefaultBehavior,T,wont_add_nz> &f,
                          TK &K,
                          TF &F,
                          TV &vectors,
                          const Number<symm> &matrix_is_sym,
                          const Number<$assemble_mat> &assemble_mat,
                          const Number<$assemble_vec> &assemble_vec,
                          const Element<$(pe->name),DefaultBehavior,Node<$nb_dim,T_pos,ND>,ED,nim> &elem,
                          const unsigned *indices) {
                              double tps_moy1=0;
                              double nb=0;
                              for (unsigned j=0; j<f.interface.elem_enrichment_ID[elem.number].size();j++) {
                                  cout<< " terme enrichissement Kphipsy et Kef : groupe " << f.interface.elem_enrichment_ID[elem.number][j] << "et j ="<< j << "et elem.number = " << elem.number << endl;
                                  // if ($(toto)) {
                                      TicToc tp1;
                                      tp1.start();
                                      add_elem_matrix_struct_$(pe->name)<TM,T, wont_add_nz, symm, T_pos, ND, ED, nim, $assemble_mat, $assemble_vec,Triangle, typename Formulation<TM,$name,DefaultBehavior,T,wont_add_nz>::THDBK> str_1;
                                      str_1.matrix_is_sym = &matrix_is_sym;
                                      str_1.assemble_mat = &assemble_mat;
                                      str_1.assemble_vec = &assemble_vec;
                                      str_1.elem = &elem;
                                      str_1.indices = indices;
                                      str_1.f = &f;
                                      str_1.id_hdbk = 0;
                                      str_1.id_group_hdbk = &j;
                                      str_1.hdbk = f.interface.elem_enrichment_ID[elem.number][j];
                                      apply_3( (f.interface.elem_enrichment_ID[elem.number][j]->formulation[0])->elem_list, (f.interface.elem_enrichment_ID[elem.number][j]->formulation[1])->elem_list, (f.interface.elem_enrichment_ID[elem.number][j]->formulation[2])->elem_list, str_1, K, F );
                                      tp1.stop();
                                      tps_moy1 += tp1.res;
                                      nb += 1;
                                  // }
                              }
                              cout <<"temps moyen par pts de gauss (enrichissement)"<< tps_moy1/nb << "pour " << nb << "patches" <<endl;
                      }
                      //
        #
        if nb_dim == 3
          stream <<<<
              template<class TM,class T,bool wont_add_nz,unsigned symm,class T_pos,class ND,class ED,unsigned nim, unsigned ass_mat, unsigned ass_vec, class TO, class THDBK>
              struct add_elem_matrix_struct_$(pe->name) { 
                  const Number<symm> *matrix_is_sym;
                  const Number<ass_mat> *assemble_mat;
                  const Number<ass_vec> *assemble_vec;
                  const Element<$(pe->name),DefaultBehavior,Node<$nb_dim,T_pos,ND>,ED,nim> *elem;
                  Formulation<TM,$name,DefaultBehavior,T,wont_add_nz> *f;
                  const unsigned *indices;
                  const unsigned *id;
                  const unsigned *id_group_hdbk;
                  const unsigned *id_hdbk;
                  THDBK* hdbk;                	
                  bool want_enr;
                  double length_frac;
                  template<class TE1,class TE2,class TE3,class TE4,class TE5,class TE6, class TK, class TF> void operator()( const TE1 elem_enr, const TE2 elem_enr1, const TE3 elem_enr2, const TE4 elem_enr3, const TE5 elem_enr4, const TE6 elem_enr5, TK &K, TF &F) const {
                      //indices[$(pe->nb_nodes_)] = hdbk->indices;
                      Gauss_Pts_for_one_element<TM,TE1> gauss_point;
                      gauss_point.prout( elem_enr, hdbk);
                      for (unsigned i=0;i<gauss_point.size();i++) {
                          double tmp_weight = length_frac*gauss_point[i].weight;
                          double sauv_weigth = gauss_point[i].weight;
                          gauss_point.pos_and_wei[i].weight = tmp_weight;
                          if(/* pos_is_inside(*elem,gauss_point[i].positions,10e-4)*/ 1) {
                              add_elem_matrix_enriched_corr( *f, K, F, f->vectors, *matrix_is_sym, *assemble_mat, *assemble_vec, *elem, indices, gauss_point[i], *id_group_hdbk, elem_enr, elem_enr1, elem_enr2, elem_enr3, elem_enr4, elem_enr5, hdbk);
                              add_elem_matrix_enriched_coupl( *f, K, F, f->vectors, *matrix_is_sym, *assemble_mat, *assemble_vec, *elem, indices, gauss_point[i], *id_group_hdbk, elem_enr, elem_enr1, elem_enr2, elem_enr3, elem_enr4, elem_enr5, hdbk);
                              if (want_enr) {
                                  gauss_point.pos_and_wei[i].weight = sauv_weigth;
                                  add_elem_matrix_enriched( *f, K, F, f->vectors, *matrix_is_sym, *assemble_mat, *assemble_vec, *elem, indices, gauss_point[i], *id_group_hdbk, elem_enr, elem_enr1,elem_enr2, elem_enr3, elem_enr4, elem_enr5, hdbk);
                              }
                          }
                      }
                  }
                  template<class TE1,class TE2,class TE3, class TK, class TF> void operator()( const TE1 elem_enr, const TE2 elem_enr1, const TE3 elem_enr2, TK &K, TF &F) const {
                      //indices[$(pe->nb_nodes_)] = hdbk->indices;
                      Gauss_Pts_for_one_element<TM,TE1> gauss_point;
                      gauss_point.prout( elem_enr, hdbk);
                      for (unsigned i=0;i<gauss_point.size();i++) {
                          double tmp_weight = length_frac*gauss_point[i].weight;
                          double sauv_weigth = gauss_point[i].weight;
                          gauss_point.pos_and_wei[i].weight = tmp_weight;
                          if(/* pos_is_inside(*elem,gauss_point[i].positions,10e-4)*/ 1) {
                              add_elem_matrix_enriched_corr( *f, K, F, f->vectors, *matrix_is_sym, *assemble_mat, *assemble_vec, *elem, indices, gauss_point[i], *id_group_hdbk, elem_enr, elem_enr1, elem_enr2, hdbk);
                              add_elem_matrix_enriched_coupl( *f, K, F, f->vectors, *matrix_is_sym, *assemble_mat, *assemble_vec, *elem, indices, gauss_point[i], *id_group_hdbk, elem_enr, elem_enr1, elem_enr2, hdbk);
                              if (want_enr) {
                                  gauss_point.pos_and_wei[i].weight = sauv_weigth;
                                  add_elem_matrix_enriched( *f, K, F, f->vectors, *matrix_is_sym, *assemble_mat, *assemble_vec, *elem, indices, gauss_point[i], *id_group_hdbk, elem_enr, elem_enr1,elem_enr2, hdbk);
                              }
                          }
                      }
                  } 
              };
          for assemble_mat in 0 .. 2
              for assemble_vec in 0 .. 2
                  stream <<<<
                      // 
                      //
                      template<class TM,class T,bool wont_add_nz,class TK,class TF,class TV, class TVV,unsigned symm,class T_pos,class ND,class ED,unsigned nim, class TEE, class TEE2, class TEE3, class THDBK>
                      void add_elem_matrix_enriched(
                          Formulation<TM,$name,DefaultBehavior,T,wont_add_nz> &f,
                          TK &K,
                          TF &F,
                          TV &vectors,
                          const Number<symm> &matrix_is_sym,
                          const Number<$assemble_mat> &assemble_mat,
                          const Number<$assemble_vec> &assemble_vec,
                          const Element<$(pe->name),DefaultBehavior,Node<$nb_dim,T_pos,ND>,ED,nim> &elem,
                          const unsigned *indices, const TVV &gauss_point, const unsigned &id_group_hdbk,const TEE &elem_enr,const TEE2 &elem_enr2,const TEE3 &elem_enr3, THDBK* hdbk ) {
                              unsigned id_offset = id_group_hdbk;
                              Interface_micro_macro_handbook_values_3D<TM,THDBK,TEE,TEE2,TEE3,TEE3,TEE3,TEE3> Fun_enr(&f.interface,hdbk,elem_enr,elem_enr2,elem_enr3);
                              Interface_micro_macro_handbook_values_dx_3D<TM,THDBK,TEE,TEE2,TEE3,TEE3,TEE3,TEE3> Fun_enr_3D_dx(&f.interface,hdbk,elem_enr,elem_enr2,elem_enr3);
                              Interface_micro_macro_handbook_values_dy_3D<TM,THDBK,TEE,TEE2,TEE3,TEE3,TEE3,TEE3> Fun_enr_3D_dy(&f.interface,hdbk,elem_enr,elem_enr2,elem_enr3);
                              Interface_micro_macro_handbook_values_dz_3D<TM,THDBK,TEE,TEE2,TEE3,TEE3,TEE3,TEE3> Fun_enr_3D_dz(&f.interface,hdbk,elem_enr,elem_enr2,elem_enr3);
                              Interface_micro_macro_handbook_values_young_<TM,THDBK,TEE> Young_enr_3D(&f.interface,hdbk,elem_enr);
                              Interface_micro_macro_handbook_values_poisson_<TM,THDBK,TEE> Poisson_enr_3D(&f.interface,hdbk,elem_enr);
                              // std::cout<<indices[0]<< " " << indices[1]<< " " << indices[2] << " " << indices[3]<< " " << indices[4]<<std::endl;
                      pthread_mutex_t* mutex = &f.mutex;
                      $( write_mat_with_cond( K_dV_enr, F_dV_enr, assemble_mat, assemble_vec, want_nodal=true, want_skin_elem=true, want_elem=true, want_global=true, want_assign=false, want_parallele=false, line_range_min=e->nb_nodes * nb_dim - 1, line_range_max=e->nb_nodes * nb_dim + 3) )
                      }
                      //
                      template<class TM,class T,bool wont_add_nz,class TK,class TF,class TV, class TVV,unsigned symm,class T_pos,class ND,class ED,unsigned nim, class TEE, class TEE2, class TEE3, class TEE4, class TEE5, class TEE6, class THDBK>
                      void add_elem_matrix_enriched(
                          Formulation<TM,$name,DefaultBehavior,T,wont_add_nz> &f,
                          TK &K,
                          TF &F,
                          TV &vectors,
                          const Number<symm> &matrix_is_sym,
                          const Number<$assemble_mat> &assemble_mat,
                          const Number<$assemble_vec> &assemble_vec,
                          const Element<$(pe->name),DefaultBehavior,Node<$nb_dim,T_pos,ND>,ED,nim> &elem,
                          const unsigned *indices, const TVV &gauss_point, const unsigned &id_group_hdbk,const TEE &elem_enr,const TEE2 &elem_enr2,const TEE3 &elem_enr3, const TEE4 &elem_enr4,const TEE5 &elem_enr5,const TEE6 &elem_enr6, THDBK* hdbk ) {
                              unsigned id_offset = id_group_hdbk;
                              Interface_micro_macro_handbook_values_3D<TM,THDBK,TEE,TEE2,TEE3,TEE4,TEE5,TEE6> Fun_enr(&f.interface,hdbk,elem_enr,elem_enr2,elem_enr3,elem_enr4,elem_enr5,elem_enr6);
                              Interface_micro_macro_handbook_values_dx_3D<TM,THDBK,TEE,TEE2,TEE3,TEE4,TEE5,TEE6> Fun_enr_3D_dx(&f.interface,hdbk,elem_enr,elem_enr2,elem_enr3,elem_enr4,elem_enr5,elem_enr6);
                              Interface_micro_macro_handbook_values_dy_3D<TM,THDBK,TEE,TEE2,TEE3,TEE4,TEE5,TEE6> Fun_enr_3D_dy(&f.interface,hdbk,elem_enr,elem_enr2,elem_enr3,elem_enr4,elem_enr5,elem_enr6);
                              Interface_micro_macro_handbook_values_dz_3D<TM,THDBK,TEE,TEE2,TEE3,TEE4,TEE5,TEE6> Fun_enr_3D_dz(&f.interface,hdbk,elem_enr,elem_enr2,elem_enr3,elem_enr4,elem_enr5,elem_enr6);
                              Interface_micro_macro_handbook_values_young_<TM,THDBK,TEE> Young_enr_3D(&f.interface,hdbk,elem_enr);
                              Interface_micro_macro_handbook_values_poisson_<TM,THDBK,TEE> Poisson_enr_3D(&f.interface,hdbk,elem_enr);
                              // std::cout<<indices[0]<< " " << indices[1]<< " " << indices[2] << " " << indices[3]<< " " << indices[4]<<std::endl;
                      pthread_mutex_t* mutex = &f.mutex;
                      $( write_mat_with_cond( K_dV_enr, F_dV_enr, assemble_mat, assemble_vec, want_nodal=true, want_skin_elem=true, want_elem=true, want_global=true, want_assign=false, want_parallele=false, line_range_min=e->nb_nodes * nb_dim - 1, line_range_max=e->nb_nodes * nb_dim + 6) )
                      }
                      //
                      //
                      template<class TM,class T,bool wont_add_nz,class TK,class TF,class TV,unsigned symm,class T_pos,class ND,class ED,unsigned nim>
                      void add_elem_matrix_enriched(
                          Formulation<TM,$name,DefaultBehavior,T,wont_add_nz> &f,
                          TK &K,
                          TF &F,
                          TV &vectors,
                          const Number<symm> &matrix_is_sym,
                          const Number<$assemble_mat> &assemble_mat,
                          const Number<$assemble_vec> &assemble_vec,
                          const Element<$(pe->name),DefaultBehavior,Node<$nb_dim,T_pos,ND>,ED,nim> &elem,
                          const unsigned *indices) {
                              double tps_moy1=0;
                              double nb=0;
                              unsigned offset = 0;
                              bool want_couplage = true;
                              bool want_enr = true;
                              unsigned indices_dupl[$(e->nb_nodes+1)];
                              for (unsigned i=0; i<$(e->nb_nodes+1); i++) { indices_dupl[i] = indices[i]; }
                              //
                              for (unsigned j=0; j<f.interface.elem_enrichment_ID[elem.number].size();j++) {
                                  cout<< " terme enrichissement Kphipsy et Kef : groupe " << f.interface.elem_enrichment_ID[elem.number][j] << "et j ="<< j << "et elem.number = " << elem.number << endl;
                                  TicToc tp1;
                                  tp1.start();
                                  add_elem_matrix_struct_$(pe->name)<TM,T, wont_add_nz, symm, T_pos, ND, ED, nim, $assemble_mat, $assemble_vec,Triangle, typename Formulation<TM,$name,DefaultBehavior,T,wont_add_nz>::THDBK> str_1;
                                  str_1.matrix_is_sym = &matrix_is_sym;
                                  str_1.assemble_mat = &assemble_mat;
                                  str_1.assemble_vec = &assemble_vec;
                                  str_1.elem = &elem;
                                  str_1.f = &f;
                                  str_1.id_hdbk = 0;
                                  str_1.id_group_hdbk = &offset; //avant j
                                  str_1.hdbk = f.interface.elem_enrichment_ID[elem.number][j];
                                  str_1.want_enr = want_enr;
                                  str_1.length_frac = 1;
                                  if (not f.interface.elem_enrichment_ID[elem.number][j]->size_in_element.empty())
                                      str_1.length_frac *= f.interface.elem_enrichment_ID[elem.number][j]->size_in_element[elem.number];
                                  //
                                  if (f.interface.elem_enrichment_ID[elem.number][j]->indices == 0) {
                                      f.interface.elem_enrichment_ID[elem.number][j]->indices = indices[$(e->nb_nodes)]+offset;
                                          str_1.indices = indices;
                                          if (f.interface.elem_enrichment_ID[elem.number][j]->formulation.size() == 6 ) {
                                              apply_6( (f.interface.elem_enrichment_ID[elem.number][j]->formulation[0])->elem_list, (f.interface.elem_enrichment_ID[elem.number][j]->formulation[1])->elem_list, (f.interface.elem_enrichment_ID[elem.number][j]->formulation[2])->elem_list,(f.interface.elem_enrichment_ID[elem.number][j]->formulation[3])->elem_list,(f.interface.elem_enrichment_ID[elem.number][j]->formulation[4])->elem_list,(f.interface.elem_enrichment_ID[elem.number][j]->formulation[5])->elem_list, str_1, K, F );
                                              offset += 6;}
                                          if (f.interface.elem_enrichment_ID[elem.number][j]->formulation.size() == 3 ) {
                                              apply_3( (f.interface.elem_enrichment_ID[elem.number][j]->formulation[0])->elem_list, (f.interface.elem_enrichment_ID[elem.number][j]->formulation[1])->elem_list, (f.interface.elem_enrichment_ID[elem.number][j]->formulation[2])->elem_list, str_1, K, F );
                                              offset += 3;}                                              
                                  }
                                  else {
                                      indices_dupl[$(e->nb_nodes)] = f.interface.elem_enrichment_ID[elem.number][j]->indices;
                                      str_1.indices = indices_dupl;
                                      want_enr = false;
                                      str_1.want_enr = want_enr;
                                      unsigned tmp = 0;
                                      str_1.id_group_hdbk = &tmp;
                                      if (f.interface.elem_enrichment_ID[elem.number][j]->formulation.size() == 6 ) {
                                          apply_6( (f.interface.elem_enrichment_ID[elem.number][j]->formulation[0])->elem_list, (f.interface.elem_enrichment_ID[elem.number][j]->formulation[1])->elem_list, (f.interface.elem_enrichment_ID[elem.number][j]->formulation[2])->elem_list,(f.interface.elem_enrichment_ID[elem.number][j]->formulation[3])->elem_list,(f.interface.elem_enrichment_ID[elem.number][j]->formulation[4])->elem_list,(f.interface.elem_enrichment_ID[elem.number][j]->formulation[5])->elem_list, str_1, K, F );
                                      }
                                      if (f.interface.elem_enrichment_ID[elem.number][j]->formulation.size() == 3 ) {
                                          apply_3( (f.interface.elem_enrichment_ID[elem.number][j]->formulation[0])->elem_list, (f.interface.elem_enrichment_ID[elem.number][j]->formulation[1])->elem_list, (f.interface.elem_enrichment_ID[elem.number][j]->formulation[2])->elem_list, str_1, K, F );
                                      }
                                  }
                                  tp1.stop();
                                  tps_moy1 += tp1.res;
                                  nb += 1;
                                  // }
                              }
                              cout <<"temps moyen par pts de gauss (enrichissement)"<< tps_moy1/nb << "pour " << nb << "patches" <<endl;
                          }
                      //
        #
        stream <<< "} // namespace LMT"
        stream <<< "#endif"
        
    #
    def write_add_elem_matrices_enriched_corr( stream )
        stream <<< "#ifndef ADD_ELEM_MATRIX_ENRICHED_CORR_$(nb_dim)_$(name)_FOR_ELEMENT_$(pe->name)_H"
        stream <<< "#define ADD_ELEM_MATRIX_ENRICHED_CORR_$(nb_dim)_$(name)_FOR_ELEMENT_$(pe->name)_H"
        stream <<< "namespace LMT {"
        #
        if nb_dim == 2
          for assemble_mat in 0 .. 2
              for assemble_vec in 0 .. 2
                  stream <<<<
                      // 
                      //
                      template<class TM,class T,bool wont_add_nz,class TK,class TF,class TV, class TVV,unsigned symm,class T_pos,class ND,class ED,unsigned nim, class TEE, class TEE2, class TEE3, class THDBK>
                      void add_elem_matrix_enriched_corr(
                          Formulation<TM,$name,DefaultBehavior,T,wont_add_nz> &f,
                          TK &K,
                          TF &F,
                          TV &vectors,
                          const Number<symm> &matrix_is_sym,
                          const Number<$assemble_mat> &assemble_mat,
                          const Number<$assemble_vec> &assemble_vec,
                          const Element<$(pe->name),DefaultBehavior,Node<$nb_dim,T_pos,ND>,ED,nim> &elem,
                          const unsigned *indices, const TVV &gauss_point, const unsigned &id_group_hdbk, const TEE &elem_enr, const TEE2 &elem_enr2, const TEE3 &elem_enr3, THDBK* hdbk) {
                              Interface_micro_macro_handbook_values_<TM,THDBK,TEE,TEE2,TEE3> Fun_enr(&f.interface,hdbk,elem_enr,elem_enr2,elem_enr3);
                              Interface_micro_macro_handbook_values_dx_<TM,THDBK,TEE,TEE2,TEE3> Fun_enr_dx(&f.interface,hdbk,elem_enr,elem_enr2,elem_enr3);
                              Interface_micro_macro_handbook_values_dy_<TM,THDBK,TEE,TEE2,TEE3> Fun_enr_dy(&f.interface,hdbk,elem_enr,elem_enr2,elem_enr3);
                              Interface_micro_macro_handbook_values_young_<TM,THDBK,TEE> Young_enr(&f.interface,hdbk,elem_enr);
                              Interface_micro_macro_handbook_values_poisson_<TM,THDBK,TEE> Poisson_enr(&f.interface,hdbk,elem_enr);
                              pthread_mutex_t* mutex = &f.mutex;
                      $( write_mat( K_dV_corr, F_dV_corr, assemble_mat, assemble_vec, want_nodal=true, want_skin_elem=true, want_elem=true, want_global=true, want_parallele=false ) )
                      }
                      //
                      //
        #
        if nb_dim == 3
          for assemble_mat in 0 .. 2
              for assemble_vec in 0 .. 2
                  stream <<<<
                  stream <<<<
                      // 
                      //
                      template<class TM,class T,bool wont_add_nz,class TK,class TF,class TV, class TVV,unsigned symm,class T_pos,class ND,class ED,unsigned nim, class TEE, class TEE2, class TEE3, class TEE4, class TEE5, class TEE6, class THDBK>
                      void add_elem_matrix_enriched_corr(
                          Formulation<TM,$name,DefaultBehavior,T,wont_add_nz> &f,
                          TK &K,
                          TF &F,
                          TV &vectors,
                          const Number<symm> &matrix_is_sym,
                          const Number<$assemble_mat> &assemble_mat,
                          const Number<$assemble_vec> &assemble_vec,
                          const Element<$(pe->name),DefaultBehavior,Node<$nb_dim,T_pos,ND>,ED,nim> &elem,
                          const unsigned *indices, const TVV &gauss_point, const unsigned &id_group_hdbk, const TEE &elem_enr, const TEE2 &elem_enr2, const TEE3 &elem_enr3, const TEE4 &elem_enr4, const TEE5 &elem_enr5, const TEE6 &elem_enr6, THDBK* hdbk) {
                              Interface_micro_macro_handbook_values_3D<TM,THDBK,TEE,TEE2,TEE3,TEE4,TEE5,TEE6> Fun_enr(&f.interface,hdbk, elem_enr,elem_enr2,elem_enr3,elem_enr4,elem_enr5,elem_enr6);
                              Interface_micro_macro_handbook_values_dx_3D<TM,THDBK,TEE,TEE2,TEE3,TEE4,TEE5,TEE6> Fun_enr_3D_dx(&f.interface,hdbk,elem_enr,elem_enr2,elem_enr3,elem_enr4,elem_enr5,elem_enr6);
                              Interface_micro_macro_handbook_values_dy_3D<TM,THDBK,TEE,TEE2,TEE3,TEE4,TEE5,TEE6> Fun_enr_3D_dy(&f.interface,hdbk,elem_enr,elem_enr2,elem_enr3,elem_enr4,elem_enr5,elem_enr6);
                              Interface_micro_macro_handbook_values_dz_3D<TM,THDBK,TEE,TEE2,TEE3,TEE4,TEE5,TEE6> Fun_enr_3D_dz(&f.interface,hdbk,elem_enr,elem_enr2,elem_enr3,elem_enr4,elem_enr5,elem_enr6);
                              Interface_micro_macro_handbook_values_young_<TM,THDBK,TEE> Young_enr_3D(&f.interface,hdbk,elem_enr);
                              Interface_micro_macro_handbook_values_poisson_<TM,THDBK,TEE> Poisson_enr_3D(&f.interface,hdbk,elem_enr);
                              pthread_mutex_t* mutex = &f.mutex;
                      $( write_mat( K_dV_corr, F_dV_corr, assemble_mat, assemble_vec, want_nodal=true, want_skin_elem=true, want_elem=true, want_global=true, want_parallele=false ) )
                      }
                      //
                      template<class TM,class T,bool wont_add_nz,class TK,class TF,class TV, class TVV,unsigned symm,class T_pos,class ND,class ED,unsigned nim, class TEE, class TEE2, class TEE3, class THDBK>
                      void add_elem_matrix_enriched_corr(
                          Formulation<TM,$name,DefaultBehavior,T,wont_add_nz> &f,
                          TK &K,
                          TF &F,
                          TV &vectors,
                          const Number<symm> &matrix_is_sym,
                          const Number<$assemble_mat> &assemble_mat,
                          const Number<$assemble_vec> &assemble_vec,
                          const Element<$(pe->name),DefaultBehavior,Node<$nb_dim,T_pos,ND>,ED,nim> &elem,
                          const unsigned *indices, const TVV &gauss_point, const unsigned &id_group_hdbk, const TEE &elem_enr, const TEE2 &elem_enr2, const TEE3 &elem_enr3, THDBK* hdbk) {
                              Interface_micro_macro_handbook_values_3D<TM,THDBK,TEE,TEE2,TEE3,TEE3,TEE3,TEE3> Fun_enr(&f.interface,hdbk,elem_enr,elem_enr2,elem_enr3);
                              Interface_micro_macro_handbook_values_dx_3D<TM,THDBK,TEE,TEE2,TEE3,TEE3,TEE3,TEE3> Fun_enr_3D_dx(&f.interface,hdbk,elem_enr,elem_enr2,elem_enr3);
                              Interface_micro_macro_handbook_values_dy_3D<TM,THDBK,TEE,TEE2,TEE3,TEE3,TEE3,TEE3> Fun_enr_3D_dy(&f.interface,hdbk,elem_enr,elem_enr2,elem_enr3);
                              Interface_micro_macro_handbook_values_dz_3D<TM,THDBK,TEE,TEE2,TEE3,TEE3,TEE3,TEE3> Fun_enr_3D_dz(&f.interface,hdbk,elem_enr,elem_enr2,elem_enr3);
                              Interface_micro_macro_handbook_values_young_<TM,THDBK,TEE> Young_enr_3D(&f.interface,hdbk,elem_enr);
                              Interface_micro_macro_handbook_values_poisson_<TM,THDBK,TEE> Poisson_enr_3D(&f.interface,hdbk,elem_enr);
                              pthread_mutex_t* mutex = &f.mutex;
                      $( write_mat( K_dV_corr, F_dV_corr, assemble_mat, assemble_vec, want_nodal=true, want_skin_elem=true, want_elem=true, want_global=true, want_parallele=false ) )
                      }
                      //
        #
        stream <<< "} // namespace LMT"
        stream <<< "#endif"

    #
    def write_add_elem_matrices_enriched_coupl( stream )
        e := child_cast(pe)
        stream <<< "#ifndef ADD_ELEM_MATRIX_ENRICHED_COUPL_$(nb_dim)_$(name)_FOR_ELEMENT_$(pe->name)_H"
        stream <<< "#define ADD_ELEM_MATRIX_ENRICHED_COUPL_$(nb_dim)_$(name)_FOR_ELEMENT_$(pe->name)_H"
        stream <<< "namespace LMT {"
        #
        if nb_dim == 2
          for assemble_mat in 0 .. 2
              for assemble_vec in 0 .. 2
                  stream <<<<
                      // 
                      //
                      template<class TM,class T,bool wont_add_nz,class TK,class TF,class TV, class TVV,unsigned symm,class T_pos,class ND,class ED,unsigned nim, class TEE, class TEE2, class TEE3, class THDBK>
                      void add_elem_matrix_enriched_coupl(
                          Formulation<TM,$name,DefaultBehavior,T,wont_add_nz> &f,
                          TK &K,
                          TF &F,
                          TV &vectors,
                          const Number<symm> &matrix_is_sym,
                          const Number<$assemble_mat> &assemble_mat,
                          const Number<$assemble_vec> &assemble_vec,
                          const Element<$(pe->name),DefaultBehavior,Node<$nb_dim,T_pos,ND>,ED,nim> &elem,
                          const unsigned *indices, const TVV &gauss_point, const unsigned &id_group_hdbk, const TEE &elem_enr, const TEE2 &elem_enr2, const TEE3 &elem_enr3, THDBK* hdbk) {
                              unsigned id = id_group_hdbk;
                              Interface_micro_macro_handbook_values_<TM,THDBK,TEE,TEE2,TEE3> Fun_enr(&f.interface,hdbk,elem_enr,elem_enr2,elem_enr3);
                              Interface_micro_macro_handbook_values_dx_<TM,THDBK,TEE,TEE2,TEE3> Fun_enr_dx(&f.interface,hdbk,elem_enr,elem_enr2,elem_enr3);
                              Interface_micro_macro_handbook_values_dy_<TM,THDBK,TEE,TEE2,TEE3> Fun_enr_dy(&f.interface,hdbk,elem_enr,elem_enr2,elem_enr3);
                              Interface_micro_macro_handbook_values_young_<TM,THDBK,TEE> Young_enr(&f.interface,hdbk,elem_enr);
                              Interface_micro_macro_handbook_values_poisson_<TM,THDBK,TEE> Poisson_enr(&f.interface,hdbk,elem_enr);
                              pthread_mutex_t* mutex = &f.mutex;
                      $( write_mat( K_dV_coupl, F_dV_coupl, assemble_mat, assemble_vec, want_nodal=true, want_skin_elem=true, want_elem=true, want_global=true, want_parallele=false ) )
                      }
                      //
                      //
        #
        if nb_dim == 3
          for assemble_mat in 0 .. 2
              for assemble_vec in 0 .. 2
                  stream <<<<
                  stream <<<<
                      // 
                      //
                      template<class TM,class T,bool wont_add_nz,class TK,class TF,class TV, class TVV,unsigned symm,class T_pos,class ND,class ED,unsigned nim, class TEE, class TEE2, class TEE3, class TEE4, class TEE5, class TEE6, class THDBK>
                      void add_elem_matrix_enriched_coupl(
                          Formulation<TM,$name,DefaultBehavior,T,wont_add_nz> &f,
                          TK &K,
                          TF &F,
                          TV &vectors,
                          const Number<symm> &matrix_is_sym,
                          const Number<$assemble_mat> &assemble_mat,
                          const Number<$assemble_vec> &assemble_vec,
                          const Element<$(pe->name),DefaultBehavior,Node<$nb_dim,T_pos,ND>,ED,nim> &elem,
                          const unsigned *indices, const TVV &gauss_point, const unsigned &id_group_hdbk, const TEE &elem_enr, const TEE2 &elem_enr2, const TEE3 &elem_enr3, const TEE4 &elem_enr4, const TEE5 &elem_enr5, const TEE6 &elem_enr6, THDBK* hdbk) {
                              unsigned id_offset = id_group_hdbk;
                              Interface_micro_macro_handbook_values_3D<TM,THDBK,TEE,TEE2,TEE3,TEE4,TEE5,TEE6> Fun_enr(&f.interface,hdbk,elem_enr,elem_enr2,elem_enr3,elem_enr4,elem_enr5,elem_enr6);
                              Interface_micro_macro_handbook_values_dx_3D<TM,THDBK,TEE,TEE2,TEE3,TEE4,TEE5,TEE6> Fun_enr_3D_dx(&f.interface,hdbk,elem_enr,elem_enr2,elem_enr3,elem_enr4,elem_enr5,elem_enr6);
                              Interface_micro_macro_handbook_values_dy_3D<TM,THDBK,TEE,TEE2,TEE3,TEE4,TEE5,TEE6> Fun_enr_3D_dy(&f.interface,hdbk,elem_enr,elem_enr2,elem_enr3,elem_enr4,elem_enr5,elem_enr6);
                              Interface_micro_macro_handbook_values_dz_3D<TM,THDBK,TEE,TEE2,TEE3,TEE4,TEE5,TEE6> Fun_enr_3D_dz(&f.interface,hdbk,elem_enr,elem_enr2,elem_enr3,elem_enr4,elem_enr5,elem_enr6);
                              Interface_micro_macro_handbook_values_young_<TM,THDBK,TEE> Young_enr_3D(&f.interface,hdbk,elem_enr);
                              Interface_micro_macro_handbook_values_poisson_<TM,THDBK,TEE> Poisson_enr_3D(&f.interface,hdbk,elem_enr);
                              pthread_mutex_t* mutex = &f.mutex;
                              $( write_mat_with_cond( K_dV_coupl, F_dV_coupl, assemble_mat, assemble_vec, want_nodal=true, want_skin_elem=true, want_elem=true, want_global=true, want_assign=false, want_parallele=false, line_range_min=e->nb_nodes * nb_dim - 1, line_range_max=e->nb_nodes * nb_dim + 6) )
                      }
                      //
                      template<class TM,class T,bool wont_add_nz,class TK,class TF,class TV, class TVV,unsigned symm,class T_pos,class ND,class ED,unsigned nim, class TEE, class TEE2, class TEE3, class THDBK>
                      void add_elem_matrix_enriched_coupl(
                          Formulation<TM,$name,DefaultBehavior,T,wont_add_nz> &f,
                          TK &K,
                          TF &F,
                          TV &vectors,
                          const Number<symm> &matrix_is_sym,
                          const Number<$assemble_mat> &assemble_mat,
                          const Number<$assemble_vec> &assemble_vec,
                          const Element<$(pe->name),DefaultBehavior,Node<$nb_dim,T_pos,ND>,ED,nim> &elem,
                          const unsigned *indices, const TVV &gauss_point, const unsigned &id_group_hdbk, const TEE &elem_enr, const TEE2 &elem_enr2, const TEE3 &elem_enr3, THDBK* hdbk) {
                              unsigned id_offset = id_group_hdbk;
                              Interface_micro_macro_handbook_values_3D<TM,THDBK,TEE,TEE2,TEE3,TEE3,TEE3,TEE3> Fun_enr(&f.interface,hdbk,elem_enr,elem_enr2,elem_enr3);
                              Interface_micro_macro_handbook_values_dx_3D<TM,THDBK,TEE,TEE2,TEE3,TEE3,TEE3,TEE3> Fun_enr_3D_dx(&f.interface,hdbk,elem_enr,elem_enr2,elem_enr3);
                              Interface_micro_macro_handbook_values_dy_3D<TM,THDBK,TEE,TEE2,TEE3,TEE3,TEE3,TEE3> Fun_enr_3D_dy(&f.interface,hdbk,elem_enr,elem_enr2,elem_enr3);
                              Interface_micro_macro_handbook_values_dz_3D<TM,THDBK,TEE,TEE2,TEE3,TEE3,TEE3,TEE3> Fun_enr_3D_dz(&f.interface,hdbk,elem_enr,elem_enr2,elem_enr3);
                              Interface_micro_macro_handbook_values_young_<TM,THDBK,TEE> Young_enr_3D(&f.interface,hdbk,elem_enr);
                              Interface_micro_macro_handbook_values_poisson_<TM,THDBK,TEE> Poisson_enr_3D(&f.interface,hdbk,elem_enr);
                              pthread_mutex_t* mutex = &f.mutex;
                              $( write_mat_with_cond( K_dV_coupl, F_dV_coupl, assemble_mat, assemble_vec, want_nodal=true, want_skin_elem=true, want_elem=true, want_global=true, want_assign=false, want_parallele=false, line_range_min=e->nb_nodes * nb_dim - 1, line_range_max=e->nb_nodes * nb_dim + 3) )
                      }
                      //
        #
        stream <<< "} // namespace LMT"
        stream <<< "#endif"

    # 
    def write_add_nodal_matrices( stream )
        stream <<< "#ifndef ADD_NODAL_MATRIX_$(name)_H"
        stream <<< "#define ADD_NODAL_MATRIX_$(name)_H"
        stream <<< "namespace LMT {"
        for assemble_mat in 0 .. 2
            for assemble_vec in 0 .. 2
                stream <<<<
                    template<class TM,class TK,class TF,class TV,class T,bool wont_add_nz,unsigned symm>
                    void add_nodal_matrix(
                        Formulation<TM,$name,DefaultBehavior,T,wont_add_nz> &f,
                        TK &K,
                        TF &F,
                        TV &vectors,
                        const Number<symm> &matrix_is_sym,
                        const Number<$assemble_mat> &assemble_mat,
                        const Number<$assemble_vec> &assemble_vec,
                        const typename TM::TNode &node,
                        const unsigned *indices ) {
                        #define PNODE(N) (&node)
                    $( write_mat( K_dN, F_dN, assemble_mat, assemble_vec, want_nodal=true, want_skin_elem=false, want_elem=false, want_global=true ) )
                        #undef PNODE
                    }
                    template<class TM,class T,bool wont_add_nz,unsigned symm>
                    void add_nodal_matrix(
                        Formulation<TM,$name,DefaultBehavior,T,wont_add_nz> &f,
                        const Number<symm> &matrix_is_sym,
                        const Number<$assemble_mat> &assemble_mat,
                        const Number<$assemble_vec> &assemble_vec,
                        const typename TM::TNode &node,
                        const unsigned *indices ) {
                        add_nodal_matrix( f, f.matrices(Number<0>()), f.sollicitation, f.vectors, matrix_is_sym, assemble_mat, assemble_vec, node, indices );
                    }
        for assemble_mat_A in 0 .. 2
            for assemble_mat_B in 0 .. 2
                stream <<<<
                    template<class TM,class TK,class TV,class T,bool wont_add_nz,unsigned Asymm,unsigned Bsymm>
                    void add_nodal_matrix(
                        Formulation<TM,$name,DefaultBehavior,T,wont_add_nz> &f,
                        TK &A,
                        TK &B,
                        TV &vectors,
                        const Number<Asymm> &matrix_A_is_sym,
                        const Number<Bsymm> &matrix_B_is_sym,
                        const Number<$assemble_mat_A> &assemble_mat_A,
                        const Number<$assemble_mat_B> &assemble_mat_B,
                        const typename TM::TNode &node,
                        const unsigned *indices ) {
                        #define PNODE(N) (&node)
                    $( write_mat_eig( A_dN, B_dN, assemble_mat_A, assemble_mat_B, want_nodal=true, want_skin_elem=false, want_elem=false, want_global=true ) )
                        #undef PNODE
                    }
                    template<class TM,class T,bool wont_add_nz,unsigned Asymm,unsigned Bsymm,unsigned Csymm>
                    void add_nodal_matrix(
                        Formulation<TM,$name,DefaultBehavior,T,wont_add_nz> &f,
                        const Number<Asymm> &matrix_A_is_sym,
                        const Number<Bsymm> &matrix_B_is_sym,
                        const Number<$assemble_mat_A> &assemble_mat_A,
                        const Number<$assemble_mat_B> &assemble_mat_B,
                        const typename TM::TNode &node,
                        const unsigned *indices ) {
                        add_nodal_matrix( f, f.matrices(Number<1>()), f.matrices(Number<2>()), f.vectors, matrix_A_is_sym, matrix_B_is_sym, assemble_mat_A, assemble_mat_B, node, indices );
                    }
        for assemble_mat in 0 .. 2
            stream <<<<
                template<class TM,class TK,class TV,class T,bool wont_add_nz,unsigned symm>
                void add_nodal_matrix(
                    Formulation<TM,$name,DefaultBehavior,T,wont_add_nz> &f,
                    TK &C,
                    TV &vectors,
                    const Number<symm> &matrix_is_sym,
                    const Number<$assemble_mat> &assemble_mat,
                    const typename TM::TNode &node,
                    const unsigned *indices ) {
                    #define PNODE(N) (&node)
                $( write_mat_eq( C_dN, assemble_mat, want_nodal=true, want_skin_elem=false, want_elem=false, want_global=true ) )
                    #undef PNODE
                }
                template<class TM,class T,bool wont_add_nz,unsigned symm>
                void add_nodal_matrix(
                    Formulation<TM,$name,DefaultBehavior,T,wont_add_nz> &f,
                    const Number<symm> &matrix_is_sym,
                    const Number<$assemble_mat> &assemble_mat,
                    const typename TM::TNode &node,
                    const unsigned *indices ) {
                    add_nodal_matrix( f, f.matrices(Number<3>()), f.vectors, matrix_is_sym, assemble_mat, node, indices );
                }
        stream <<< "} // namespace LMT"
        stream <<< "#endif"

    # 
    def write_add_nodal_matrices_eig( stream )
        stream <<< "#ifndef ADD_NODAL_MATRIX_EIG_$(name)_H"
        stream <<< "#define ADD_NODAL_MATRIX_EIG_$(name)_H"
        stream <<< "namespace LMT {"
        for assemble_mat_A in 0 .. 2
            for assemble_mat_B in 0 .. 2
                stream <<<<
                    template<class TM,class TK,class TV,class T,bool wont_add_nz,unsigned Asymm,unsigned Bsymm>
                    void add_nodal_matrix(
                        Formulation<TM,$name,DefaultBehavior,T,wont_add_nz> &f,
                        TK &A,
                        TK &B,
                        TV &vectors,
                        const Number<Asymm> &matrix_A_is_sym,
                        const Number<Bsymm> &matrix_B_is_sym,
                        const Number<$assemble_mat_A> &assemble_mat_A,
                        const Number<$assemble_mat_B> &assemble_mat_B,
                        const typename TM::TNode &node,
                        const unsigned *indices ) {
                        #define PNODE(N) (&node)
                    $( write_mat_eig( A_dN, B_dN, assemble_mat_A, assemble_mat_B, want_nodal=true, want_skin_elem=false, want_elem=false, want_global=true ) )
                        #undef PNODE
                    }
                    template<class TM,class T,bool wont_add_nz,unsigned Asymm,unsigned Bsymm,unsigned Csymm>
                    void add_nodal_matrix(
                        Formulation<TM,$name,DefaultBehavior,T,wont_add_nz> &f,
                        const Number<Asymm> &matrix_A_is_sym,
                        const Number<Bsymm> &matrix_B_is_sym,
                        const Number<$assemble_mat_A> &assemble_mat_A,
                        const Number<$assemble_mat_B> &assemble_mat_B,
                        const typename TM::TNode &node,
                        const unsigned *indices ) {
                        add_nodal_matrix( f, f.matrices(Number<1>()), f.matrices(Number<2>()), f.vectors, matrix_A_is_sym, matrix_B_is_sym, assemble_mat_A, assemble_mat_B, node, indices );
                    }
        for assemble_mat in 0 .. 2
            stream <<<<
                template<class TM,class TK,class TV,class T,bool wont_add_nz,unsigned symm>
                void add_nodal_matrix(
                    Formulation<TM,$name,DefaultBehavior,T,wont_add_nz> &f,
                    TK &C,
                    TV &vectors,
                    const Number<symm> &matrix_is_sym,
                    const Number<$assemble_mat> &assemble_mat,
                    const typename TM::TNode &node,
                    const unsigned *indices ) {
                    #define PNODE(N) (&node)
                $( write_mat_eq( C_dN, assemble_mat, want_nodal=true, want_skin_elem=false, want_elem=false, want_global=true ) )
                    #undef PNODE
                }
                template<class TM,class T,bool wont_add_nz,unsigned symm>
                void add_nodal_matrix(
                    Formulation<TM,$name,DefaultBehavior,T,wont_add_nz> &f,
                    const Number<symm> &matrix_is_sym,
                    const Number<$assemble_mat> &assemble_mat,
                    const typename TM::TNode &node,
                    const unsigned *indices ) {
                    add_nodal_matrix( f, f.matrices(Number<3>()), f.vectors, matrix_is_sym, assemble_mat, node, indices );
                }
        stream <<< "} // namespace LMT"
        stream <<< "#endif"
    
    
#~

~#
class LmtppFormulation[ dim ] inherits LmtppFormulationAncestor
    pos := Variable[[dim]]( unit="m", tex_name = "X" )
    Id  := Mat[Op,Sym[dim]]( function = x => (x[0]==x[1]) )
    
    #
    def init( e, prefix_form = "" )
        init_using_default_values( self )
        update_variable_expr_and_test( e, prefix_form )
        formulation_init( e )
        if set_pos_field_as_it_was_from_lower_degree_element
            e.set_pos_field_as_it_was_from_lower_degree_element()
        
    #
    def init
        init_using_default_values( self )
        formulation_init( None )
    
    #
    virtual def get_nb_dim
        return dim
        
    #
    def update_variable_expr_and_test( e, prefix_form )
        pe = &e
        pe_children = pe->children( 1 )
    
        # update expr and test
        unknown_variables.size = 0
        unk_expr_syms    .size = 0
        unk_test_syms    .size = 0
        max_nb_der             = 0
        all_K_are_linear       = true
        for name, var in AttributeExplorer( self )
            if var.is_a_LmtppVariable
                var.from_formulation = this
                variables.push_back( &var )
                var.update_computed_attributes_pass_0( time, e, name, self )
                max_nb_der = max( max_nb_der, var.nb_der )
                if var.unknown
                    unknown_variables.push_back( &var )
        
        for name, var in AttributeExplorer( self )
            if var.is_a_LmtppVariable
                var.update_computed_attributes_pass_1( time, e, name, self )
                    
        # subs list to have unknown_variables in vectors[0]
        mesh_subs      := Vec[Op]()
        vect_subs      := Vec[Op]()
        num_in_indices := 0
        has_node_unknowns := false; nb_node_unk := 0
        has_elem_unknowns := false; nb_elem_unk := 0
        has_glob_unknowns := false; nb_glob_unk := 0
        has_skin_unknowns := false; nb_skin_unk := 0
        for num_node in 0 .. e.nb_nodes
            nb_node_unk = 0
            _update_unk( unknown_variables, mesh_subs, vect_subs, num_in_indices, has_node_unknowns, nb_node_unk, _0.node == num_node, prefix_form )
        _update_unk( unknown_variables, mesh_subs, vect_subs, num_in_indices, has_elem_unknowns, nb_elem_unk, _0.elem == 0, prefix_form )
        _update_unk( unknown_variables, mesh_subs, vect_subs, num_in_indices, has_glob_unknowns, nb_glob_unk, _0.glob == 0, prefix_form )
        _update_unk( unknown_variables, mesh_subs, vect_subs, num_in_indices, has_skin_unknowns, nb_skin_unk, _0.skin == 0, prefix_form )
        
        # apply subs list
        for v in unknown_variables
            v->make_expr_subs( mesh_subs, vect_subs )
                
                
    # @see update_variable_expr_and_test
    def _update_unk( unknown_variables, mesh_subs, vect_subs, num_in_indices, has__unknowns, nb__unk, function_crit, prefix_form )
        for v in unknown_variables
            for s in v->expr_symbols
                if function_crit( s )
                    s.off_ind = nb__unk
                    mesh_subs.push_back( s.sym )
                    syms := Vec[ Op ]( size = v->nb_der + 1, function = symbol(prefix_form+"vectors[$_0]["+prefix_form+"indices[$num_in_indices]+$nb__unk]","V_{$_0,$num_in_indices,$nb__unk}") )
                    tims := Vec[ Op ]( size = v->nb_der + 1, function = time_steps[0] - sum( time_steps[ 0 .. _0 ] ) )
                    vect_subs.push_back( lagrange( tims, syms, time ) )
                    s.sym = syms[ 0 ]
                    nb__unk++
                    has__unknowns = true
                    #
                    unk_expr_syms.push_back( &s )
        #                    
        for v in unknown_variables
            for s in v->test_symbols
                if function_crit( s )
                    unk_test_syms.push_back( &s )
        #                    
        num_in_indices += has__unknowns

    #

    def make_matrices( e, integration_type = "gauss_num", assume_const_jac_in_elems = true, degre_poly_handbook = 1 )
        e.assume_const_jac = true
        residual_const_jac := Op( formulation( e ) )
        e.assume_const_jac = assume_const_jac_in_elems
        residual := Op( formulation( e ) )

        # time integration
        if max_nb_der
            if use_theta_method
                residual = residual.subs( time, theta * time_steps[1] )
            else
                residual = integration( residual, time, left_time_integration * time_steps[1], right_time_integration * time_steps[0] )
        
        # volumic part
        volumic_part := residual.diff( dV )
        degre_poly := volumic_part.poly_deg( e.var_inter )
        if degre_poly < 0
            volumic_part_const_jac := residual_const_jac.diff( dV )
            degre_poly = volumic_part_const_jac.poly_deg( e.var_inter )
        volumic_part_handbook := residual.diff( dV_handbook )
        if integration_type == "bestial_num"
            volumic_part = e.bestial_num_integration( volumic_part, mul_by_jac = true, div_ = 6 )
            volumic_part_handbook = e.bestial_num_integration( volumic_part_handbook, mul_by_jac = true, div_ = 10 )
        else if integration_type == "gauss_num"
            volumic_part = e.gauss_num_integration( volumic_part, order_diff = degre_poly )
            volumic_part_handbook = e.gauss_num_integration( volumic_part_handbook, order_diff = degre_poly_handbook )
        else if integration_type == "formal"
            volumic_part = e.integration( volumic_part, order_diff = degre_poly )
            volumic_part_handbook = e.integration( volumic_part_handbook, order_diff = degre_poly_handbook )
        volumic_part += volumic_part_handbook
        volumic_part += residual.diff( dE )
        _compute_KF_from_residual( volumic_part, K_dV, F_dV, unk_expr_syms.map( _0->sym ), unk_test_syms.map( _0->sym ) )
        
        # nodal part
        nodal_part := residual.diff( dN )
        nodal_part = nodal_part.subs( e.var_inter, e.points[ 0 ] )
        _compute_KF_from_residual( nodal_part, K_dN, F_dN, 
            unk_expr_syms.filter( _0->node >=0 or _0->glob >= 0 ).map( _0->sym ), 
            unk_test_syms.filter( _0->node >=0 or _0->glob >= 0 ).map( _0->sym )
        )
        
        # surf parts
        surf_part := residual.diff( dS )
        surf_part_const_jac := residual_const_jac.diff( dS )
        internal_surf_part := residual.diff( diF )
        internal_surf_part_const_jac := residual_const_jac.diff( diF )
        surf_part_handbook := residual.diff( dS_handbook )
        internal_surf_part_handbook := residual.diff( diF_handbook )
        K_dS.resize( pe_children.size )
        F_dS.resize( pe_children.size )
        K_diF.resize( pe_children.size )
        F_diF.resize( pe_children.size )
        for pc_, num_child in pe_children, 0...
            pc := child_cast( pc_ )
            loc_surf_part := surf_part.subs( e.var_inter, e.var_inter_from_child_var_inter( sub_nvi = 1, num_child = num_child, child_var_inter = pc->var_inter ) )
            degre_poly_surf := loc_surf_part.poly_deg( pc->var_inter )
            if degre_poly_surf < 0
                loc_surf_part_const_jac := surf_part_const_jac.subs( e.var_inter, e.var_inter_from_child_var_inter( sub_nvi = 1, num_child = num_child, child_var_inter = pc->var_inter ) )
                degre_poly_surf = loc_surf_part_const_jac.poly_deg( pc->var_inter )
            loc_internal_surf_part := internal_surf_part.subs( e.var_inter, e.var_inter_from_child_var_inter( sub_nvi = 1, num_child = num_child, child_var_inter = pc->var_inter ) )
            degre_poly_internal_surf := loc_internal_surf_part.poly_deg( pc->var_inter )
            if degre_poly_internal_surf < 0
                loc_internal_surf_part_const_jac := internal_surf_part_const_jac.subs( e.var_inter, e.var_inter_from_child_var_inter( sub_nvi = 1, num_child = num_child, child_var_inter = pc->var_inter ) )
                degre_poly_internal_surf = loc_internal_surf_part_const_jac.poly_deg( pc->var_inter )
            loc_surf_part_handbook := surf_part_handbook.subs( e.var_inter, e.var_inter_from_child_var_inter( sub_nvi = 1, num_child = num_child, child_var_inter = pc->var_inter ) )
            loc_internal_surf_part_handbook := internal_surf_part_handbook.subs( e.var_inter, e.var_inter_from_child_var_inter( sub_nvi = 1, num_child = num_child, child_var_inter = pc->var_inter ) )
            if integration_type == "bestial_num"
                loc_surf_part = pc->bestial_num_integration( loc_surf_part, mul_by_jac = true, div_ = 6 )
                loc_internal_surf_part = pc->bestial_num_integration( loc_internal_surf_part, mul_by_jac = true, div_ = 6 )
                loc_surf_part_handbook = pc->bestial_num_integration( loc_surf_part_handbook, mul_by_jac = true, div_ = 10 )
                loc_internal_surf_part_handbook = pc->bestial_num_integration( loc_internal_surf_part_handbook, mul_by_jac = true, div_ = 10 )
            else if integration_type == "gauss_num"
                loc_surf_part = pc->gauss_num_integration( loc_surf_part, order_diff = degre_poly_surf )
                loc_internal_surf_part = pc->gauss_num_integration( loc_internal_surf_part, order_diff = degre_poly_internal_surf )
                loc_surf_part_handbook = pc->gauss_num_integration( loc_surf_part_handbook, order_diff = degre_poly_handbook )
                loc_internal_surf_part_handbook = pc->gauss_num_integration( loc_internal_surf_part_handbook, order_diff = degre_poly_handbook )
            else if integration_type == "formal"
                loc_surf_part = pc->integration( loc_surf_part, order_diff = degre_poly_surf )
                loc_internal_surf_part = pc->integration( loc_internal_surf_part, order_diff = degre_poly_internal_surf )
                loc_surf_part_handbook = pc->integration( loc_surf_part_handbook, order_diff = degre_poly_handbook )
                loc_internal_surf_part_handbook = pc->integration( loc_internal_surf_part_handbook, order_diff = degre_poly_handbook )
            loc_surf_part += loc_surf_part_handbook
            _compute_KF_from_residual( loc_surf_part, K_dS[ num_child ], F_dS[ num_child ],
                unk_expr_syms.map( _0->sym ), 
                unk_test_syms.map( _0->sym )
            )
            loc_internal_surf_part += loc_internal_surf_part_handbook
            _compute_KF_from_residual( loc_internal_surf_part, K_diF[ num_child ], F_diF[ num_child ],
                unk_expr_syms.map( _0->sym ), 
                unk_test_syms.map( _0->sym )
            )

    def make_matrices_eig( e, integration_type = "gauss_num", assume_const_jac_in_elems = true )
        e.assume_const_jac = true
        residual_const_jac := Op( formulation( e ) )
        e.assume_const_jac = assume_const_jac_in_elems
        residual := Op( formulation( e ) )

        # time integration
        if max_nb_der
            if use_theta_method
                residual = residual.subs( time, theta * time_steps[1] )
            else
                residual = integration( residual, time, left_time_integration * time_steps[1], right_time_integration * time_steps[0] )
        
        # volumic part
        volumic_part_A := residual.diff( dV_eig_A )
        volumic_part_B := residual.diff( dV_eig_B )
        degre_poly_A := volumic_part_A.poly_deg( e.var_inter )
        degre_poly_B := volumic_part_B.poly_deg( e.var_inter )
        if degre_poly_A < 0
            volumic_part_A_const_jac := residual_const_jac.diff( dV_eig_A )
            degre_poly_A = volumic_part_A_const_jac.poly_deg( e.var_inter )
        if degre_poly_B < 0
            volumic_part_B_const_jac := residual_const_jac.diff( dV_eig_B )
            degre_poly_B = volumic_part_B_const_jac.poly_deg( e.var_inter )
        if integration_type == "bestial_num"
            volumic_part_A = e.bestial_num_integration( volumic_part_A, mul_by_jac = true, div_ = 6 )
            volumic_part_B = e.bestial_num_integration( volumic_part_B, mul_by_jac = true, div_ = 6 )
        else if integration_type == "gauss_num"
            volumic_part_A = e.gauss_num_integration( volumic_part_A, order_diff = degre_poly_A )
            volumic_part_B = e.gauss_num_integration( volumic_part_B, order_diff = degre_poly_B )
        else if integration_type == "formal"
            volumic_part_A = e.integration( volumic_part_A, order_diff = degre_poly_A )
            volumic_part_B = e.integration( volumic_part_B, order_diff = degre_poly_B )
        volumic_part_A += residual.diff( dE_eig_A )
        volumic_part_B += residual.diff( dE_eig_B )
        _compute_K_from_residual( volumic_part_A, A_dV, unk_expr_syms.map( _0->sym ), unk_test_syms.map( _0->sym ) )
        _compute_K_from_residual( volumic_part_B, B_dV, unk_expr_syms.map( _0->sym ), unk_test_syms.map( _0->sym ) )
        
        # nodal part
        nodal_part_A := residual.diff( dN_eig_A )
        nodal_part_A = nodal_part_A.subs( e.var_inter, e.points[ 0 ] )
        nodal_part_B := residual.diff( dN_eig_B )
        nodal_part_B = nodal_part_B.subs( e.var_inter, e.points[ 0 ] )
        _compute_K_from_residual( nodal_part_A, A_dN, 
            unk_expr_syms.filter( _0->node >=0 or _0->glob >= 0 ).map( _0->sym ), 
            unk_test_syms.filter( _0->node >=0 or _0->glob >= 0 ).map( _0->sym )
        )
        _compute_K_from_residual( nodal_part_B, B_dN, 
            unk_expr_syms.filter( _0->node >=0 or _0->glob >= 0 ).map( _0->sym ), 
            unk_test_syms.filter( _0->node >=0 or _0->glob >= 0 ).map( _0->sym )
        )
        
        # surf parts
        surf_part_A := residual.diff( dS_eig_A )
        surf_part_B := residual.diff( dS_eig_B )
        surf_part_A_const_jac := residual_const_jac.diff( dS_eig_A )
        surf_part_B_const_jac := residual_const_jac.diff( dS_eig_B )
        internal_surf_part_A := residual.diff( diF_eig_A )
        internal_surf_part_B := residual.diff( diF_eig_B )
        internal_surf_part_A_const_jac := residual_const_jac.diff( diF_eig_A )
        internal_surf_part_B_const_jac := residual_const_jac.diff( diF_eig_B )
        A_dS.resize( pe_children.size )
        B_dS.resize( pe_children.size )
        A_diF.resize( pe_children.size )
        B_diF.resize( pe_children.size )
        for pc_, num_child in pe_children, 0...
            pc := child_cast( pc_ )
            loc_surf_part_A := surf_part_A.subs( e.var_inter, e.var_inter_from_child_var_inter( sub_nvi = 1, num_child = num_child, child_var_inter = pc->var_inter ) )
            loc_surf_part_B := surf_part_B.subs( e.var_inter, e.var_inter_from_child_var_inter( sub_nvi = 1, num_child = num_child, child_var_inter = pc->var_inter ) )
            degre_poly_surf_A := loc_surf_part_A.poly_deg( pc->var_inter )
            degre_poly_surf_B := loc_surf_part_B.poly_deg( pc->var_inter )
            if degre_poly_surf_A < 0
                loc_surf_part_A_const_jac := surf_part_A_const_jac.subs( e.var_inter, e.var_inter_from_child_var_inter( sub_nvi = 1, num_child = num_child, child_var_inter = pc->var_inter ) )
                degre_poly_surf_A = loc_surf_part_A_const_jac.poly_deg( pc->var_inter )
            if degre_poly_surf_B < 0
                loc_surf_part_B_const_jac := surf_part_B_const_jac.subs( e.var_inter, e.var_inter_from_child_var_inter( sub_nvi = 1, num_child = num_child, child_var_inter = pc->var_inter ) )
                degre_poly_surf_B = loc_surf_part_B_const_jac.poly_deg( pc->var_inter )
            loc_internal_surf_part_A := internal_surf_part_A.subs( e.var_inter, e.var_inter_from_child_var_inter( sub_nvi = 1, num_child = num_child, child_var_inter = pc->var_inter ) )
            loc_internal_surf_part_B := internal_surf_part_B.subs( e.var_inter, e.var_inter_from_child_var_inter( sub_nvi = 1, num_child = num_child, child_var_inter = pc->var_inter ) )
            degre_poly_internal_surf_A := loc_internal_surf_part_A.poly_deg( pc->var_inter )
            degre_poly_internal_surf_B := loc_internal_surf_part_B.poly_deg( pc->var_inter )
            if degre_poly_internal_surf_A < 0
                loc_internal_surf_part_A_const_jac := internal_surf_part_A_const_jac.subs( e.var_inter, e.var_inter_from_child_var_inter( sub_nvi = 1, num_child = num_child, child_var_inter = pc->var_inter ) )
                degre_poly_internal_surf_A = loc_internal_surf_part_A_const_jac.poly_deg( pc->var_inter )
            if degre_poly_internal_surf_B < 0
                loc_internal_surf_part_B_const_jac := internal_surf_part_B_const_jac.subs( e.var_inter, e.var_inter_from_child_var_inter( sub_nvi = 1, num_child = num_child, child_var_inter = pc->var_inter ) )
                degre_poly_internal_surf_B = loc_internal_surf_part_B_const_jac.poly_deg( pc->var_inter )
            if integration_type == "bestial_num"
                loc_surf_part_A = pc->bestial_num_integration( loc_surf_part_A, mul_by_jac = true, div_ = 6 )
                loc_surf_part_A = pc->bestial_num_integration( loc_surf_part_B, mul_by_jac = true, div_ = 6 )
                loc_internal_surf_part_A = pc->bestial_num_integration( loc_internal_surf_part_A, mul_by_jac = true, div_ = 6 )
                loc_internal_surf_part_B = pc->bestial_num_integration( loc_internal_surf_part_B, mul_by_jac = true, div_ = 6 )
            else if integration_type == "gauss_num"
                loc_surf_part_A = pc->gauss_num_integration( loc_surf_part_A, order_diff = degre_poly_surf_A )
                loc_surf_part_B = pc->gauss_num_integration( loc_surf_part_B, order_diff = degre_poly_surf_B )
                loc_internal_surf_part_A = pc->gauss_num_integration( loc_internal_surf_part_A, order_diff = degre_poly_internal_surf_A )
                loc_internal_surf_part_B = pc->gauss_num_integration( loc_internal_surf_part_B, order_diff = degre_poly_internal_surf_B )
            else if integration_type == "formal"
                loc_surf_part_A = pc->integration( loc_surf_part_A, order_diff = degre_poly_surf_A )
                loc_internal_surf_part_A = pc->integration( loc_internal_surf_part_A, order_diff = degre_poly_internal_surf_A )
                loc_surf_part_B = pc->integration( loc_surf_part_B, order_diff = degre_poly_surf_B )
                loc_internal_surf_part_B = pc->integration( loc_internal_surf_part_B, order_diff = degre_poly_internal_surf_B )
            _compute_K_from_residual( loc_surf_part_A, A_dS[ num_child ],
                unk_expr_syms.map( _0->sym ), 
                unk_test_syms.map( _0->sym )
            )
            _compute_K_from_residual( loc_surf_part_B, B_dS[ num_child ],
                unk_expr_syms.map( _0->sym ), 
                unk_test_syms.map( _0->sym )
            )
            _compute_K_from_residual( loc_internal_surf_part_A, A_diF[ num_child ],
                unk_expr_syms.map( _0->sym ), 
                unk_test_syms.map( _0->sym )
            )
            _compute_K_from_residual( loc_internal_surf_part_B, B_diF[ num_child ],
                unk_expr_syms.map( _0->sym ), 
                unk_test_syms.map( _0->sym )
            )

    def make_matrices_eq( e, integration_type = "gauss_num", assume_const_jac_in_elems = true )
        e.assume_const_jac = true
        residual_const_jac := Op( formulation( e ) )
        e.assume_const_jac = assume_const_jac_in_elems
        residual := Op( formulation( e ) )

        # time integration
        if max_nb_der
            if use_theta_method
                residual = residual.subs( time, theta * time_steps[1] )
            else
                residual = integration( residual, time, left_time_integration * time_steps[1], right_time_integration * time_steps[0] )
        
        C_dV.resize( Int32( pe->nb_dim*(pe->nb_dim+1)/2 ), Vec[Op]( unk_test_syms.map( _0->sym ) ).size )
        C_dN.resize( Int32( pe->nb_dim*(pe->nb_dim+1)/2 ), Vec[Op]( unk_test_syms.filter( _0->node >=0 or _0->glob >= 0 ).map( _0->sym ) ).size )
        for n in 0 .. Int32( pe->nb_dim*(pe->nb_dim+1)/2 )
            # volumic part
            volumic_part_C := residual.diff( dV_eig_C[ n ] )
            degre_poly_C := volumic_part_C.poly_deg( e.var_inter )
            if degre_poly_C < 0
                volumic_part_C_const_jac := residual_const_jac.diff( dV_eig_C[ n ] )
                degre_poly_C = volumic_part_C_const_jac.poly_deg( e.var_inter )
            if integration_type == "bestial_num"
                volumic_part_C = e.bestial_num_integration( volumic_part_C, mul_by_jac = true, div_ = 6 )
            else if integration_type == "gauss_num"
                volumic_part_C = e.gauss_num_integration( volumic_part_C, order_diff = degre_poly_C )
            else if integration_type == "formal"
                volumic_part_C = e.integration( volumic_part_C, order_diff = degre_poly_C )
            volumic_part_C += residual.diff( dE_eig_C[ n ] )
            C_dV_tmp := Vec[ Op ]()
            _compute_F_from_residual( volumic_part_C, C_dV_tmp, unk_expr_syms.map( _0->sym ), unk_test_syms.map( _0->sym ) )
            C_dV.row( n ) = C_dV_tmp
            
            # nodal part
            nodal_part_C := residual.diff( dN_eig_C[ n ] )
            nodal_part_C = nodal_part_C.subs( e.var_inter, e.points[ 0 ] )
            C_dN_tmp := Vec[ Op ]()
            _compute_F_from_residual( nodal_part_C, C_dN_tmp, 
                unk_expr_syms.filter( _0->node >=0 or _0->glob >= 0 ).map( _0->sym ), 
                unk_test_syms.filter( _0->node >=0 or _0->glob >= 0 ).map( _0->sym )
            )
            C_dN.row( n ) = C_dN_tmp
            
        # surf parts
        C_dS.resize( pe_children.size )
        C_diF.resize( pe_children.size )
        for pc_, num_child in pe_children, 0...
            C_dS[ num_child ].resize( Int32( pe->nb_dim*(pe->nb_dim+1)/2 ), Vec[Op]( unk_test_syms.map( _0->sym ) ).size )
            C_diF[ num_child ].resize( Int32( pe->nb_dim*(pe->nb_dim+1)/2 ), Vec[Op]( unk_test_syms.map( _0->sym ) ).size )
        for n in 0 .. Int32( pe->nb_dim*(pe->nb_dim+1)/2 )
            surf_part_C := residual.diff( dS_eig_C[ n ] )
            surf_part_C_const_jac := residual_const_jac.diff( dS_eig_C[ n ] )
            internal_surf_part_C := residual.diff( diF_eig_C[ n ] )
            internal_surf_part_C_const_jac := residual_const_jac.diff( diF_eig_C[ n ] )
            for pc_, num_child in pe_children, 0...
                pc := child_cast( pc_ )
                loc_surf_part_C := surf_part_C.subs( e.var_inter, e.var_inter_from_child_var_inter( sub_nvi = 1, num_child = num_child, child_var_inter = pc->var_inter ) )
                degre_poly_surf_C := loc_surf_part_C.poly_deg( pc->var_inter )
                if degre_poly_surf_C < 0
                    loc_surf_part_C_const_jac := surf_part_C_const_jac.subs( e.var_inter, e.var_inter_from_child_var_inter( sub_nvi = 1, num_child = num_child, child_var_inter = pc->var_inter ) )
                    degre_poly_surf_C = loc_surf_part_C_const_jac.poly_deg( pc->var_inter )
                loc_internal_surf_part_C := internal_surf_part_C.subs( e.var_inter, e.var_inter_from_child_var_inter( sub_nvi = 1, num_child = num_child, child_var_inter = pc->var_inter ) )
                degre_poly_internal_surf_C := loc_internal_surf_part_C.poly_deg( pc->var_inter )
                if degre_poly_internal_surf_C < 0
                    loc_internal_surf_part_C_const_jac := internal_surf_part_C_const_jac.subs( e.var_inter, e.var_inter_from_child_var_inter( sub_nvi = 1, num_child = num_child, child_var_inter = pc->var_inter ) )
                    degre_poly_internal_surf_C = loc_internal_surf_part_C_const_jac.poly_deg( pc->var_inter )
                if integration_type == "bestial_num"
                    loc_surf_part_C = pc->bestial_num_integration( loc_surf_part_C, mul_by_jac = true, div_ = 6 )
                    loc_internal_surf_part_C = pc->bestial_num_integration( loc_internal_surf_part_C, mul_by_jac = true, div_ = 6 )
                else if integration_type == "gauss_num"
                    loc_surf_part_C = pc->gauss_num_integration( loc_surf_part_C, order_diff = degre_poly_surf_C )
                    loc_internal_surf_part_C = pc->gauss_num_integration( loc_internal_surf_part_C, order_diff = degre_poly_internal_surf_C )
                else if integration_type == "formal"
                    loc_surf_part_C = pc->integration( loc_surf_part_C, order_diff = degre_poly_surf_C )
                    loc_internal_surf_part_C = pc->integration( loc_internal_surf_part_C, order_diff = degre_poly_internal_surf_C )
                C_dS_tmp := Vec[ Op ]()
                _compute_F_from_residual( loc_surf_part_C, C_dS_tmp,
                    unk_expr_syms.map( _0->sym ), 
                    unk_test_syms.map( _0->sym )
                )
                C_dS[ num_child ].row( n ) = C_dS_tmp
                C_diF_tmp := Vec[ Op ]()
                _compute_F_from_residual( loc_internal_surf_part_C, C_diF_tmp,
                    unk_expr_syms.map( _0->sym ), 
                    unk_test_syms.map( _0->sym )
                )
                C_diF[ num_child ].row( n ) = C_diF_tmp
        
    def make_matrices_enriched( e, assume_const_jac_in_elems = true )
        e.assume_const_jac = true
        residual_const_jac := Op( formulation( e ) )
        e.assume_const_jac = assume_const_jac_in_elems
        residual := Op( formulation( e ) )
        
        # volumic part
        volumic_part := residual.diff( dV_enr )
        degre_poly := volumic_part.poly_deg( e.var_inter )
        if degre_poly < 0
            volumic_part_const_jac := residual_const_jac.diff( dV )
            degre_poly = volumic_part_const_jac.poly_deg( e.var_inter )
        volumic_part = e.eval_on_gauss_pts( volumic_part, mul_by_jac = false, order_diff = degre_poly )
        _compute_KF_from_residual( volumic_part, K_dV_enr, F_dV_enr, unk_expr_syms.map( _0->sym ), unk_test_syms.map( _0->sym ) )

    def make_matrices_coupl( e, assume_const_jac_in_elems = true )
        e.assume_const_jac = true
        residual_const_jac := Op( formulation( e ) )
        e.assume_const_jac = assume_const_jac_in_elems
        residual := Op( formulation( e ) )

        # volumic part
        volumic_part := residual.diff( dV_coupl )
        degre_poly := volumic_part.poly_deg( e.var_inter )
        if degre_poly < 0
            volumic_part_const_jac := residual_const_jac.diff( dV )
            degre_poly = volumic_part_const_jac.poly_deg( e.var_inter )
        volumic_part = e.eval_on_gauss_pts( volumic_part, mul_by_jac = false, order_diff = degre_poly )
        _compute_KF_from_residual( volumic_part, K_dV_coupl, F_dV_coupl, unk_expr_syms.map( _0->sym ), unk_test_syms.map( _0->sym ) )
        
    def make_matrices_enriched_corr( e, assume_const_jac_in_elems = true )
        e.assume_const_jac = true
        residual_const_jac := Op( formulation( e ) )
        e.assume_const_jac = assume_const_jac_in_elems
        residual := Op( formulation( e ) )
        
        # volumic part
        volumic_part := residual.diff( dV_corr )
        degre_poly := volumic_part.poly_deg( e.var_inter )
        if degre_poly < 0
            volumic_part_const_jac := residual_const_jac.diff( dV )
            degre_poly = volumic_part_const_jac.poly_deg( e.var_inter )
        volumic_part = e.eval_on_gauss_pts( volumic_part, mul_by_jac = false, order_diff = degre_poly )
        _compute_KF_from_residual( volumic_part, K_dV_corr, F_dV_corr, unk_expr_syms.map( _0->sym ), unk_test_syms.map( _0->sym ) )
        
    #
    def _volumic_vars( var_to_sym_lst_function )
        res := Vec[Op]()
        for v in unknown_variables
            for s in var_to_sym_lst_function( v )
                if s.skin < 0
                    res.push_back( s.sym )
        return res
        
    #
    def _compute_KF_from_residual( residual, K, F, expr_symbols_, test_symbols_ )
        expr_symbols := Vec[Op]( expr_symbols_ ) # hum
        test_symbols := Vec[Op]( test_symbols_ ) # hum
        
        # minimization ?
        if assumed( norm_1( expr_symbols - test_symbols ) == 0 )
            qe := quadratic_expansion( residual, expr_symbols )
            K = qe.m
            F = qe.v
        # else, use test_symbols
        else
            K.resize( test_symbols.size, expr_symbols.size )
            F.resize( test_symbols.size )
            # K and F
            res_diff_test := Vec[Op]()
            for test_symbol, cpt_test in test_symbols, 0...
                F[ cpt_test ] = residual.diff( test_symbol )
            for expr_symbol, cpt_expr in expr_symbols, 0...
                K.col( cpt_expr ) = diff( F, expr_symbol )
            # if non linear / test_symbols
            K =  K.subs( test_symbols, expr_symbols )
            F = -F.subs( test_symbols, expr_symbols )
            
        # if linear simplification, else, we K U_n+1 = F + K U_n
        linear_expr := not K.depends_on( expr_symbols )
        all_K_are_linear &= linear_expr
        if linear_expr
            F = F.subs( expr_symbols, expr_symbols * 0 )
        else
            F += K * expr_symbols
        
    #
    def _compute_K_from_residual( residual, K, expr_symbols_, test_symbols_ )
        expr_symbols := Vec[Op]( expr_symbols_ ) # hum
        test_symbols := Vec[Op]( test_symbols_ ) # hum
        F := Vec[Op]()
        
        # minimization ?
        if assumed( norm_1( expr_symbols - test_symbols ) == 0 )
            qe := quadratic_expansion( residual, expr_symbols )
            K = qe.m
            F = qe.v
        # else, use test_symbols
        else
            K.resize( test_symbols.size, expr_symbols.size )
            F.resize( test_symbols.size )
            # K and F
            res_diff_test := Vec[Op]()
            for test_symbol, cpt_test in test_symbols, 0...
                F[ cpt_test ] = residual.diff( test_symbol )
            for expr_symbol, cpt_expr in expr_symbols, 0...
                K.col( cpt_expr ) = diff( F, expr_symbol )
            # if non linear / test_symbols
            K =  K.subs( test_symbols, expr_symbols )
        
    #
    def _compute_F_from_residual( residual, F, expr_symbols_, test_symbols_ )
        expr_symbols := Vec[Op]( expr_symbols_ ) # hum
        test_symbols := Vec[Op]( test_symbols_ ) # hum
        K := Mat[Op]()
        
        # minimization ?
        if assumed( norm_1( expr_symbols - test_symbols ) == 0 )
            qe := quadratic_expansion( residual, expr_symbols )
            K = qe.m
            F = qe.v
        # else, use test_symbols
        else
            K.resize( test_symbols.size, expr_symbols.size )
            F.resize( test_symbols.size )
            # K and F
            res_diff_test := Vec[Op]()
            for test_symbol, cpt_test in test_symbols, 0...
                F[ cpt_test ] = residual.diff( test_symbol )
            for expr_symbol, cpt_expr in expr_symbols, 0...
                K.col( cpt_expr ) = diff( F, expr_symbol )
            # if non linear / test_symbols
            K =  K.subs( test_symbols, expr_symbols )
            F = -F.subs( test_symbols, expr_symbols )
            
        # if linear simplification, else, we K U_n+1 = F + K U_n
        linear_expr := not K.depends_on( expr_symbols )
        all_K_are_linear &= linear_expr
        if linear_expr
            F = F.subs( expr_symbols, expr_symbols * 0 )
        else
            F += K * expr_symbols

    # helpers
    def grad    ( expr )  return pe->grad    ( expr )
    def grad_sym( expr )  return pe->grad_sym( expr )
    def div     ( expr )  return pe->div     ( expr )
    def mean    ( expr )  return pe->mean    ( expr )
    
#
def write_legacy_lmtpp_mesh_dm_data_set_field( res, bn, variable_list, sym_select, sp )
    for n in 0 .. 7
        # dm_data_set_field
        TV := [ "Tpos", "Vec<Tpos,$n>" ][ n > 0 ]
        res << sp <<< "    void dm_data_set_field( const std::string field_name, $TV value ) {"
        for v in variable_list
            if sym_select( v ) and v->nb_values == n
                data_if_mat := ".data" * ( v->expr_tensor_order == 2 )
                res << sp <<< "        if ( field_name == \"$( v->name )\" ) { $( v->name + data_if_mat ) = value; return; }"
        res << sp <<< "        std::cerr << \"There's no variable named \" << field_name << \" of type $TV in data struct\" << std::endl;"
        res << sp <<< "    }"
        
        # dm_data_get_field
        res << sp <<< "    $TV dm_data_get_field( const std::string field_name, StructForType<$TV > ) const {"
        for v in variable_list
            if sym_select( v ) and v->nb_values == n
                data_if_mat := ".data" * ( v->expr_tensor_order == 2 )
                res << sp <<< "        if ( field_name == \"$( v->name )\" ) { return $( v->name + data_if_mat ); }"
        res << sp <<< "        std::cerr << \"There's no variable named \" << field_name << \" of type $TV in data struct\" << std::endl;"
        res << sp <<< "        return 0;"
        res << sp <<< "    }"

    # Mat<...,Sym<> >
    for n in 1 .. 4
        TV := "Mat<Tpos,Sym<$n> >"
        res << sp <<< "    $TV dm_data_get_field( const std::string field_name, StructForType<$TV > ) const {"
        for v in variable_list
            if sym_select( v ) and v->expr_tensor_order == 2 and v->nb_values == n * ( n + 1 ) / 2 and v->sym_property
                res << sp <<< "        if ( field_name == \"$( v->name )\" ) { return $(v->name); }"
        res << sp <<< "        std::cerr << \"There's no variable named \" << field_name << \" of type $TV in data struct\" << std::endl;"
        res << sp <<< "        return $TV();"
        res << sp <<< "    }"

    # Mat<...,Gen<> >
    for n in 1 .. 7
        TV := "Mat<Tpos,Gen<$n> >"
        res << sp <<< "    $TV dm_data_get_field( const std::string field_name, StructForType<$TV > ) const {"
        for v in variable_list
            if sym_select( v ) and v->expr_tensor_order == 2 and v->nb_values == n * n
                res << sp <<< "        if ( field_name == \"$( v->name )\" ) { return $(v->name); }"
        res << sp <<< "        std::cerr << \"There's no variable named \" << field_name << \" of type $TV in data struct\" << std::endl;"
        res << sp <<< "        return $TV();"
        res << sp <<< "    }"
        res << sp <<< "    void dm_data_set_field( const std::string field_name, const $TV &value ) {"
        for v in variable_list
            if sym_select( v ) and v->expr_tensor_order == 2 and v->nb_values == n * n
                res << sp <<< "        if ( field_name == \"$( v->name )\" ) { $(v->name) = value; }"
        res << sp <<< "        std::cerr << \"There's no variable named \" << field_name << \" of type $TV in data struct\" << std::endl;"
        res << sp <<< "    }"

#
def write_legacy_lmtpp_mesh_StaticData( bn, variable_list, sym_select, sp = "    " )
    type_variable_list := Map[String,String]()
    for v in variable_list
        if sym_select( v ) and not ( v->cpp_type in type_variable_list )
            type_variable_list[ v->cpp_type ] = "T" + type_variable_list.size
    res := ""
    res <<< sp + "struct $bn {"
    for tc, tv in type_variable_list
        res <<< sp + "    typedef $tc $tv;"
    cpt := 0
    init_const := ""
    for v in variable_list
        if sym_select( v )
            for num_der in 0 .. v->nb_der + 1
                name := v->name + "_der_$num_der" * ( num_der != 0 )
                res <<< sp + "    CARACDMEXTNAME( $cpt, $( type_variable_list[ v->cpp_type ] ), $name, \"$( v->unit )\" );"
                init_const << (":,"[cpt!=0]) << " $name( $( v->default_value_str() ) )"
                cpt++
            cpt_enr := 0
            if v->nodal_enrich.size
                for enr in 0..v->nodal_enrich[0]
                    for num_der in 0 .. v->nb_der + 1
                        name := v->name + "_ENR_$cpt_enr" + "_der_$num_der" * ( num_der != 0 )
                        res <<< sp + "    CARACDMEXTNAME( $cpt, $( type_variable_list[ v->cpp_type ] ), $name, \"$( v->unit )\" );"
                        init_const << (":,"[cpt!=0]) << " $name( $( v->default_value_str() ) )"
                        cpt++
                    cpt_enr++
    if cpt
        res <<< sp + "    static const unsigned nb_params = $cpt;"
        res <<< sp + "    $bn() $init_const {}"
    else
        res <<< sp + "    VOIDDMSET;"
    write_legacy_lmtpp_mesh_dm_data_set_field( res, bn, variable_list, sym_select, sp = sp )
    res <<< sp + "};"
    return res

#
def write_legacy_lmtpp_mesh_carac( stream, pb_name, fe_set_by_dim, dim )
    variable_list   := Set[ Ptr[ VariableAncestor ], ( x, y ) => x->eq( @y ) ]()
    name_elem_lists := Vec[ Set[ String ] ]( size = dim + 1 )
    for fn, fl in fe_set_by_dim
        for f in fl
            for sub_nvi in 0 .. dim + 1
                for c in f->pe->children( sub_nvi )
                    name_elem_lists[ sub_nvi ].insert( c->name )
            for v in f->variables
                variable_list.insert( v )
    
    # ifndef
    stream <<< "#ifndef Mesh_carac_$(pb_name)_$(dim)_HEADER"
    stream <<< "#define Mesh_carac_$(pb_name)_$(dim)_HEADER"
    stream <<< "#include <mesh/displayparaview.h>"
    for name_elems in name_elem_lists
        for name_elem in name_elems
            stream <<< "#include <mesh/$name_elem.h>"
    stream <<< "namespace LMT {"
    stream <<< "#ifndef Mesh_carac_$(pb_name)_HEADER"
    stream <<< "#define Mesh_carac_$(pb_name)_HEADER"
    stream <<< "template<class TP,unsigned dim> struct Mesh_carac_$(pb_name) {};"
    stream <<< "#endif // Mesh_carac_$(pb_name)_HEADER"
    
    # mesh data structs
    for v in variable_list
        stop := 0
        if v->nodal_enrich.size
            stop = v->nodal_enrich[0]
        for cpt_enr in -1 .. stop
            for num_der in 0 .. v->nb_der + 1
                name := v->name + "_ENR_$cpt_enr" * ( cpt_enr >= 0 ) + "_der_$num_der" * ( num_der != 0 )
                stream <<<<
                    #ifndef IFNDEF_$(name)_DM
                    #define IFNDEF_$(name)_DM
                        struct $(name)_DM { static std::string name() { return "$(name)"; } };
                    #endif // IFNDEF_$(name)_DM
        
    # CARACDMEXTNAMES
    CARACDM_NodalStaticData    := write_legacy_lmtpp_mesh_StaticData( "NodalStaticData"  , variable_list, x => ( x->interpolation in [ "nodal"     , "bubble" ] ) )
    CARACDM_GlobalStaticData   := write_legacy_lmtpp_mesh_StaticData( "GlobalStaticData" , variable_list, x =>   x->interpolation ==   "global"                   )
    CARACDM_ElemStaticData     := write_legacy_lmtpp_mesh_StaticData( "TData"            , variable_list, x => ( x->interpolation in [ "elementary", "bubble" ] ), sp = " " * 8 )
    CARACDM_SkinElemStaticData := write_legacy_lmtpp_mesh_StaticData( "TData"            , variable_list, x => ( x->interpolation in [ "skin_elementary" ] ), sp = " " * 8 )
    CARACDM_GeneElemStaticData := write_legacy_lmtpp_mesh_StaticData( "TData"            , variable_list, x => false, sp = " " * 8 )
    
    # elem lst
    element_choices := ""
    element_choices <<<< 
            template<unsigned nvi_to_subs,unsigned skin,unsigned num_sub_element,unsigned inner=0> struct ElementChoice {
                typedef void NE;
                typedef DefaultBehavior BE;
                typedef VoidDMSet TData; 
            };
    for sub_nvi in 0 .. name_elem_lists.size
        for ne, cpt in name_elem_lists[ sub_nvi ], 0...
            element_choices <<<< 
                    template<unsigned skin,unsigned inner> struct ElementChoice<$sub_nvi,skin,$cpt,inner> {
                        typedef $ne NE;
                        typedef DefaultBehavior BE;
                $( [CARACDM_ElemStaticData,CARACDM_SkinElemStaticData,CARACDM_GeneElemStaticData,CARACDM_GeneElemStaticData][ sub_nvi ] )
                    };
    
    # mesh carac
    stream <<<<
        template<class TP>
        struct Mesh_carac_$(pb_name)<TP,$dim> {
            typedef TP Tpos;
            static const unsigned dim = $dim;
            typedef Vec<TP,dim> Pvec;
        $CARACDM_NodalStaticData
        $CARACDM_GlobalStaticData
        $element_choices
        };
        } // namespace LMT
        #endif // Mesh_carac_$(pb_name)_$(dim)_HEADER


#
def write_legacy_lmtpp_carac_formulation( stream, name_form, fe_set_by_dim_and_name, dim )
    is_unknown         := ""
    num_in_vec_unknown := ""
    cpt_unknown        := 0
    for v in fe_set_by_dim_and_name[0]->unknown_variables
        stop := 0
        if v->nodal_enrich.size
            stop = v->nodal_enrich[0]
        for cpt_enr in -1 .. stop
            is_unknown << [""," or "][cpt_unknown!=0] << "s == \"$( v->name + "_ENR_$cpt_enr" * ( cpt_enr >= 0 ) )\""
            num_in_vec_unknown << "if ( s == \"$( v->name + "_ENR_$cpt_enr" * ( cpt_enr >= 0 ) )\" ) return $cpt_unknown;"
            cpt_unknown += v->nb_values
    
    if not is_unknown
        is_unknown = "false"
    
    f := fe_set_by_dim_and_name[0]
    matrix_will_be_definite_positive := f->matrix_will_be_definite_positive
    
    #
    stream <<<<
        // generated file. Do not modify
        #include "formulation/formulation.h"
        
        namespace LMT {
        #ifndef CARAC_FORMULATION_$(dim)_$(name_form)_H
        #define CARAC_FORMULATION_$(dim)_$(name_form)_H
        #ifndef STRUCT_FORMULATION_$(name_form)
        #define STRUCT_FORMULATION_$(name_form)
        struct $(name_form) {
            static const char *name() { return "$(name_form)"; }
        };
        #endif // STRUCT_FORMULATION_$(name_form)
        
        template<class P_T>
        class CaracFormulation<$(name_form),$dim,P_T>  {
        public:
            typedef P_T T;
            static const char *name() { return "$(name_form)"; }
            static const bool matrix_will_be_definite_positive = $matrix_will_be_definite_positive;
            static const bool has_nodal_matrix = true;
            static const bool has_IS_contact_matrix = false;
            static const bool need_skin_assembly = $( any( fe_set_by_dim_and_name.map( x => x->need_skin_assembly ) ) );
            typedef Norm1_is_inf Name_convergence_criterium;
            static const unsigned nb_vectors = $( max( fe_set_by_dim_and_name.map( x => x->max_nb_der ) ) + 4 );
            static const unsigned nb_matrices = 4;
            static const unsigned auto_contact = false;
            static const bool friction_coeff_is_a_nodal_variable = 0;
            static const unsigned offset_of_pos_unknown = 3;
            static const unsigned pos_is_an_unknown = false;
            static const unsigned order_integration = 2;
            static const unsigned nb_der_var = 0;
            template<class TF> static void add_to_der_vars( TF &f, const Vec<T> &v ) {
            }
            static bool is_unknown(const std::string &s) { return ( $is_unknown ); }
            static unsigned num_in_vec_unknown(const std::string &s) { $num_in_vec_unknown return 0;  }
            template<unsigned num_mat,unsigned inner=0> struct NodalMatricesCarac {
                static const bool symm = $( all( fe_set_by_dim_and_name.map( x => x->K_dN.is_sym_rt ) ) );
                static const bool herm = false;
                static const bool diag = $( all( fe_set_by_dim_and_name.map( x => x->K_dN.is_diag_rt ) ) );
            };
            template<unsigned num_mat,unsigned inner=0> struct GlobalMatricesCarac {
                static const bool symm = $( all( fe_set_by_dim_and_name.map( x => x->K_dG.is_sym_rt ) ) );
                static const bool herm = false;
                static const bool diag = $( all( fe_set_by_dim_and_name.map( x => x->K_dG.is_diag_rt ) ) );
            };
        $( fe_set_by_dim_and_name[0]->legacy_lmtpp_unk_management( "nodal" , "node", x => x.node==0 ) )
        $( fe_set_by_dim_and_name[0]->legacy_lmtpp_unk_management( "global", "mesh", x => x.glob==0 ) )
        };
        
        } // namespace LMT
        #endif // CARAC_FORMULATION_$(dim)_$(name_form)_H

#
#
def write_legacy_lmtpp_carac_formulation_for_element( stream, name_form, fe, dim )
    # symm := fe->K_dV.get_is_sym_rt()
    symm := fe->assumed_symmetric_matrix
    stream <<< "// generated file. Do not edit."
    stream <<< "#ifndef CARAC_FORMULATION_$(dim)_$(name_form)_FOR_ELEMENT_$(fe->pe->name)_H"
    stream <<< "#define CARAC_FORMULATION_$(dim)_$(name_form)_FOR_ELEMENT_$(fe->pe->name)_H"
    stream <<< ""
    stream <<< "namespace LMT {"
    stream <<< ""
    stream <<< "class $(fe->pe->name);"
    stream <<< "template<unsigned A,class B,class C> class Node;"
    stream <<< "template<class A,class B,class C,class D,unsigned E> class Element;"
    stream <<< ""
    stream <<< "// Carac for ..."
    stream <<< ""
    stream <<< "template<class P_T_pos,class P_ND,class TED,unsigned nim,class TM,class T>"
    stream <<< "class CaracFormulationForElement<$name_form,Element<$(fe->pe->name),DefaultBehavior,Node<$dim,P_T_pos,P_ND>,TED,nim>,TM,T> {"
    stream <<< "public:"
    stream <<< "    template<unsigned num_mat,unsigned inner=0> struct ElemMatricesCarac {"
    stream <<< "        static const bool symm = $symm;"
    stream <<< "        static const bool herm = $symm;"
    stream <<< "        static const bool diag = false;"
    stream <<< "        static const bool linear = $( fe->all_K_are_linear );"
    stream <<< "    };"
    stream <<< "    static const unsigned order_integration = $( max( child_cast( fe->pe )->order_interpolation ) );"
    stream <<< "    static const bool has_elementary_matrix = $( fe->non_null_system( fe->K_dV, fe->F_dV ) );"
    stream <<< "    static const bool has_skin_elementary_matrix = $( fe->need_skin_assembly );"
    stream <<< "    static const bool has_internal_face_matrix = $( fe->need_internal_face_assembly );"
    stream <<< "    template<class TE,class TF,class TVEVE> static void after_solve(TE &elem,TF &f,TVEVE &vectors,const unsigned *indices) {"
    stream <<< "    #define PNODE(N) elem.node(N)"
    if not fe->want_GFEM
        stream <<< fe->call_after_solve( @child_cast( fe->pe ) )
    stream <<< "    #undef PNODE"
    stream <<< "    }"
    stream <<< "    template<class TE,class TF> static void after_solve(TE &elem,TF &f,const unsigned *indices) {"
    stream <<< "        after_solve(elem,f,f.vectors,indices);"
    stream <<< "    }"
    for n in 2 .. 16
        stream <<< "    template<class TE,class TF,class TVEVE> static void after_solve_$n(TE &elem,TF &f,TVEVE &vectors,const unsigned *indices) {"
        stream <<< "    }"
    stream <<< fe->legacy_lmtpp_unk_management( "elementary"     , "elem", x => x.elem==0 )
    stream <<< fe->legacy_lmtpp_unk_management( "skin_elementary", "elem", x => x.skin==0 )
    stream <<< "};"
    stream <<< "} // namespace"
    stream <<< "#endif // CARAC_FORMULATION_$(dim)_$(name_form)_FOR_ELEMENT_$(fe->pe->name)_H"

    
#~ ~#
def write_legacy_lmtpp_problem_h_file( stream, pb_name, fe_set, typeList )
    stream <<< "#ifndef PROBLEM_$(pb_name)_H"
    stream <<< "#define PROBLEM_$(pb_name)_H"
    for dim, fe_set_by_dim in fe_set
        for name_form, fe_set_by_dim_and_name in fe_set_by_dim
            stream <<<<
                #ifndef has_formulation_$name_form
                #define has_formulation_$name_form
                #endif
    stream <<< "#include \"mesh_carac.h\""
    stream <<< "#include <formulation/problem_ancestor.h>"
    stream <<< "namespace LMT {"
    stream <<< ""
    stream <<< "template<class T,unsigned dim> class Problem_$pb_name;"
    for t, num_type in typeList, 0...
        for dim, fe_set_by_dim in fe_set
            stream <<<<
                class Problem_$(pb_name)_type$(num_type)_$dim : public ProblemAncestor<double> {
                public:
                    typedef Mesh<Mesh_carac_toto<$t,$dim> > TM;
                    Problem_$(pb_name)_type$(num_type)_$dim() {}
                    Problem_$(pb_name)_type$(num_type)_$dim( TM &m, bool use_tim_davis=false ) {
                        if ( use_tim_davis ) {
            for name_form, fe_set_by_dim_and_name in fe_set_by_dim
                stream <<< "            formulation_$name_form = new_formulation_$name_form( Number<true >(), m );"
            stream <<< "        } else {"
            for name_form, fe_set_by_dim_and_name in fe_set_by_dim
                stream <<< "            formulation_$name_form = new_formulation_$name_form( Number<false>(), m );"
            stream <<<<
                        }
                    }
                    virtual unsigned nb_formulations() const { return $(fe_set_by_dim.size); }
                    virtual FormulationAncestor<$t> *formulation_nb(unsigned i) {
                        switch(i) {
            cpt_form := 0
            for name_form, fe_set_by_dim_and_name in fe_set_by_dim
                stream <<< "        case $(cpt_form++): return formulation_$name_form;"
            stream <<<<
                        default: return NULL;
                        }
                    }
            for name_form, fe_set_by_dim_and_name in fe_set_by_dim
                stream <<< "    static FormulationAncestor<$t> *new_formulation_$name_form( Number<false>, TM &m );"
                stream <<< "    static FormulationAncestor<$t> *new_formulation_$name_form( Number<true >, TM &m );"
                stream <<< "    FormulationAncestor<$t> *formulation_$name_form;"
            stream <<<<
                };
                template<> class Problem_toto<$t,$dim> : public Problem_$(pb_name)_type$(num_type)_$dim {
                public:
                    Problem_toto(TM &m,bool use_tim_davis=false):Problem_$(pb_name)_type$(num_type)_$dim(m,use_tim_davis) {}
                };
        
    stream <<< "} // namespace LMT"
    stream <<< "#endif // PROBLEM_$(pb_name)_H"
        
#~ ~#
def write_legacy_lmtpp_all_in_one_file( stream, pb_name, fe_set, typeList, list_sup_all_in_one, want_latin )
    stream <<<< 
        #ifndef all_in_one_h
        #define all_in_one_h
        #include <formulation/formulation.h>
        #include "mesh_carac.h"
    for dim, fe_set_by_dim in fe_set
        for name_form, fe_set_by_dim_and_name in fe_set_by_dim
            stream <<<< 
                #include "form_carac_$name_form.$dim.h"
                #include "add_nodal_matrices_$name_form.$dim.h"
            for fe in fe_set_by_dim_and_name
                stream <<<< 
                    #include "form_carac_$name_form.$dim.$(fe->pe->name).h"
                    #include "add_matrices_$name_form.$dim.$(fe->pe->name).h"
            for fe in fe_set_by_dim_and_name
                if fe->want_GFEM
                        stream <<<<
                            #include "add_matrices_enriched_$name_form.$dim.$(fe->pe->name).h"
                            #include "add_matrices_corrected_$name_form.$dim.$(fe->pe->name).h"
                            #include "add_matrices_coupl_$name_form.$dim.$(fe->pe->name).h" 
    file_name_done := Set[String]()
    for file_name in list_sup_all_in_one
        if not ( file_name in file_name_done )
            file_name_done.insert( file_name )
            stream <<<<
                #include "$file_name"
    if want_latin
        stream <<<<
            #include "latin_funcs.h"
    stream <<<<
        #endif
        
    #

#~ ~#
def write_legacy_lmtpp_problem_cpp_file( stream, pb_name, fe_set, typeList )
    for dim, fe_set_by_dim in fe_set
        for name_form, fe_set_by_dim_and_name in fe_set_by_dim
            stream <<<< 
                #include "form_carac_$name_form.$dim.h"
            for fe in fe_set_by_dim_and_name
                stream <<<< 
                    #include "form_carac_$name_form.$dim.$(fe->pe->name).h"
                    #include "add_matrices_$name_form.$dim.$(fe->pe->name).h"
    #

def write_add_W_chap_F_chap( stream, e_sst, e_int )
    nb_dim := e_sst.dim
    #
    dep_syms := Vec[Op]()
    det_syms := Vec[Op]()
    dep    := e_sst.new_variable( "dep", nb_dim = [ nb_dim ], sym = dep_syms )
    det    := e_sst.new_variable( "det", nb_dim = [ nb_dim ], sym = det_syms )
    W_chap := Vec[Op,nb_dim]( x => symbol("elem_int.W_chap[$x]") )
    F_chap := Vec[Op,nb_dim]( x => symbol("elem_int.F_chap[$x]") )
    k_chap := Vec[Op,nb_dim]( x => symbol("elem_int.k_chap[$x]") )
    my_sgn := symbol("my_sgn")
    expr   := dot( dep - W_chap, k_chap * det ) - dot( F_chap, det ) * my_sgn
    degre_poly_sst := expr.poly_deg( e_sst.var_inter )
    expr    = e_sst.integration( expr #~* e_int.point_is_inside( e_sst.pos )~#, order_diff = degre_poly_sst )
    dexp   := expr.diff( det_syms )
    ddex   := dexp.diff( dep_syms )
    cwm := CodeWriterAlt("T_pos_0")
    cwv := CodeWriterAlt("T_pos_0")
    for i in 0 .. det_syms.size
        v := - dexp[i].subs( det_syms, det_syms * 0 ).subs( dep_syms, dep_syms * 0 )
        cwm.add( "vec[ ind[ elem_sst.node( $( i // nb_dim ) )->number ] + $( i % nb_dim ) ]", v, add )
        cwv.add( "vec[ ind[ elem_sst.node( $( i // nb_dim ) )->number ] + $( i % nb_dim ) ]", v, add )
        for j in 0 .. i + 1
            cwm.add( "mat( ind[ elem_sst.node( $( i // nb_dim ) )->number ] + $( i % nb_dim ), ind[ elem_sst.node( $( j // nb_dim ) )->number ] + $( j % nb_dim ) )", ddex[i,j], add )
    #
    cwa := CodeWriterAlt("T_pos_0")
    cwa.add( "res", e_sst.mean( e_sst.pos ) == e_int.mean( e_int.pos ), reassign )
    # cwa.add( "res", e_sst.integration( e_int.point_is_inside( e_sst.pos ), false ), reassign )
    #
    stream <<<<
        namespace LMT {
        template<class T_pos_0,class ND_0,class ED_0,unsigned nim_0,class T_pos_1,class ND_1,class ED_1,unsigned nim_1,class Mat,class Vec,class Tin>
        void add_W_chap_F_chap(
            const Element<$(e_sst.name),DefaultBehavior,Node<$nb_dim,T_pos_0,ND_0>,ED_0,nim_0> &elem_sst,
            const Element<$(e_int.name),DefaultBehavior,Node<$nb_dim,T_pos_1,ND_1>,ED_1,nim_1> &elem_int,
            Mat &mat,
            Vec &vec,
            Tin &ind,
            int my_sgn
        ) {
        $(cwm.to_string())
        }
        template<class T_pos_0,class ND_0,class ED_0,unsigned nim_0,class T_pos_1,class ND_1,class ED_1,unsigned nim_1,class Vec,class Tin>
        void add_W_chap_F_chap(
            const Element<$(e_sst.name),DefaultBehavior,Node<$nb_dim,T_pos_0,ND_0>,ED_0,nim_0> &elem_sst,
            const Element<$(e_int.name),DefaultBehavior,Node<$nb_dim,T_pos_1,ND_1>,ED_1,nim_1> &elem_int,
            Vec &vec,
            Tin &ind,
            int my_sgn
        ) {
        $(cwv.to_string())
        }
        //
        template<class T_pos_0,class ND_0,class ED_0,unsigned nim_0,class T_pos_1,class ND_1,class ED_1,unsigned nim_1>
        T_pos_0 add_W_chap_F_chap(
            const Element<$(e_sst.name),DefaultBehavior,Node<$nb_dim,T_pos_0,ND_0>,ED_0,nim_0> &elem_sst,
            const Element<$(e_int.name),DefaultBehavior,Node<$nb_dim,T_pos_1,ND_1>,ED_1,nim_1> &elem_int
        ) {
            T_pos_0 res;
        $(cwa.to_string())
            return res;
        }
        }
    
#~
    TfList -> [ FormulationType1, FormulationType2, ... ] ex : FormulationElasticity
    TeList -> [ ElementType1, ElementType2, ... ] ex : Triangle, Quad, ...
    funcList -> [ Function1, Function2, ... ]
~#
def write_legacy_lmtpp_code( pb_name, TfList, TeList, dim_function = x => x::nvi, base_rep = "build", typeList = ["double"], assume_const_jac_in_elems = true, funcList = [], h_file = "", want_latin = false, want_eig = false, want_GFEM = false, integration_type = "gauss_num", degre_poly_handbook = 1 )
    fe_set := Map[ Int32 #~dim~#, Map[ String #~Formulation~#, Vec[ Ptr[ LmtppFormulationAncestor ] ] ] ]()
    list_sup_all_in_one := Vec[ String ]()
    list_f := Vec[ Ptr[ LmtppFormulationAncestor ] ]()

    # files
    rep := base_rep + "/" * Bool( base_rep.size ) + "problem_" + pb_name
    mkdir( rep )
    
    for Tf in TfList
        for Te in TeList
            e := new SymbolicElement[ Te, dim_function( Te ) ]( name_node = "PNODE" )
            e->assume_const_jac = assume_const_jac_in_elems
            f := new Tf[ dim = e->dim ]( @e, "" )
            fe_set[ f->nb_dim ][ Tf ].push_back( f )
            f->name = Tf
            #
            f->make_matrices( @e, integration_type, assume_const_jac_in_elems, degre_poly_handbook )
            if want_eig
                f->want_eig = true
                f->make_matrices_eig( @e, integration_type, assume_const_jac_in_elems )
                f->make_matrices_eq( @e, integration_type, assume_const_jac_in_elems )
            if want_GFEM
                f->want_GFEM = true
                f->make_matrices_enriched( @e, assume_const_jac_in_elems )
                f->make_matrices_coupl( @e, assume_const_jac_in_elems )
                f->make_matrices_enriched_corr( @e, assume_const_jac_in_elems )
            list_f.push_back( f )
            # f->K_dV.display_tex()

    for func in funcList
        list_sup_all_in_one.append( func( list_f, rep ) )

    # all_in_one
    write_legacy_lmtpp_all_in_one_file( File( rep + "/all_in_one.h", "w" ), pb_name, fe_set, typeList, list_sup_all_in_one, want_latin )
    
    # h_file
    if h_file
        File( h_file, "w" ) <<<< 
            #include "$rep/all_in_one.h"
    
    # problem
    write_legacy_lmtpp_problem_h_file( File( rep + "/problem.h", "w" ), pb_name, fe_set, typeList )
    
    # mesh_carac
    mesh_carac_file := File( rep + "/mesh_carac.h", "w" )
    for dim, fe_set_by_dim in fe_set
        write_legacy_lmtpp_mesh_carac( mesh_carac_file, pb_name, fe_set_by_dim, dim )
    
    # carac_formulation
    for dim, fe_set_by_dim in fe_set
        for name_form, fe_set_by_dim_and_name in fe_set_by_dim
            write_legacy_lmtpp_carac_formulation( File( rep + "/form_carac_$name_form.$dim.h", "w" ), name_form, fe_set_by_dim_and_name, dim )
            for fe in fe_set_by_dim_and_name
                # info rep + "/form_carac_$name_form.$dim.$(fe->pe->name).h"
                write_legacy_lmtpp_carac_formulation_for_element( File( rep + "/form_carac_$name_form.$dim.$(fe->pe->name).h", "w" ), name_form, fe, dim )
    
    # nodal, elementary and global matrices
    for dim, fe_set_by_dim in fe_set
        for name_form, fe_set_by_dim_and_name in fe_set_by_dim
            for fe, cpt_elem in fe_set_by_dim_and_name, 0...
                if not cpt_elem
                    fe->write_add_nodal_matrices( File( rep + "/add_nodal_matrices_$name_form.$dim.h", "w" ) )
                    if fe->want_eig
                        fe->write_add_nodal_matrices_eig( File( rep + "/add_nodal_matrices_eig_$name_form.$dim.h", "w" ) )
                fe->write_add_elem_matrices( File( rep + "/add_matrices_$name_form.$dim.$(fe->pe->name).h", "w" ) )
                if fe->want_eig
                    fe->write_add_elem_matrices_eig( File( rep + "/add_matrices_eig_$name_form.$dim.$(fe->pe->name).h", "w" ) )
                if fe->want_GFEM
                    fe->write_add_elem_matrices_enriched( File( rep + "/add_matrices_enriched_$name_form.$dim.$(fe->pe->name).h", "w" ) )
                    fe->write_add_elem_matrices_enriched_corr( File( rep + "/add_matrices_corrected_$name_form.$dim.$(fe->pe->name).h", "w" ) )
                    fe->write_add_elem_matrices_enriched_coupl( File( rep + "/add_matrices_coupl_$name_form.$dim.$(fe->pe->name).h", "w" ) )
    
    # latin -> W_chap and F_chap from interfaces
    if want_latin
        sst_elements := SplittedVec[AutoPtr[SymbolicElementAncestor],8]()
        int_elements := SplittedVec[AutoPtr[SymbolicElementAncestor],8]()
        for Te in TeList
            dim := dim_function( Te )
            e := new SymbolicElement[ Te, dim ]()
            for c_ in e->children( 1 )
                c := child_cast( c_ )
                if not ( c->name in sst_elements.map( _0->name ) )
                    sst_elements.push_back( new SymbolicElement[ c->Te, dim ]( name_elem = "elem_sst" ) )
                    int_elements.push_back( new SymbolicElement[ c->Te, dim ]( name_elem = "elem_int" ) )
        #
        f := File( rep + "/latin_funcs.h", "w" )
        for c0 in sst_elements
            for c1 in int_elements
                write_add_W_chap_F_chap( f, @child_cast( c0 ), @child_cast( c1 ) )
                
    
    
    
    
